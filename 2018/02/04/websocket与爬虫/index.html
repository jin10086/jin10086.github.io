<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>websocket与爬虫 | 高金的博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="背景 写爬虫的目的应该就是为了拿到数据，或者说模拟某种操作 如果他使用的是http(s) 协议来传输数据的，那么我们就模拟http协议来发送数据 如果它使用的是websocket协议来传输数据的， 那么我们理所当然的就模拟websocket来发送数据~  首先，我们需要了解什么是websocket  websocket的介绍 WebSocket是一种在单个TCP连接上进行全双工通讯的协议。WebS"><meta name="keywords" content="websocket,websocket抓包"><meta property="og:type" content="article"><meta property="og:title" content="websocket与爬虫"><meta property="og:url" content="https://igaojin.me/2018/02/04/websocket与爬虫/index.html"><meta property="og:site_name" content="高金的博客"><meta property="og:description" content="背景 写爬虫的目的应该就是为了拿到数据，或者说模拟某种操作 如果他使用的是http(s) 协议来传输数据的，那么我们就模拟http协议来发送数据 如果它使用的是websocket协议来传输数据的， 那么我们理所当然的就模拟websocket来发送数据~  首先，我们需要了解什么是websocket  websocket的介绍 WebSocket是一种在单个TCP连接上进行全双工通讯的协议。WebS"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://igaojin.me/2018/02/04/websocket与爬虫/0.jpg"><meta property="og:image" content="https://igaojin.me/2018/02/04/websocket与爬虫/1.jpg"><meta property="og:image" content="https://igaojin.me/2018/02/04/websocket与爬虫/2.jpg"><meta property="og:image" content="https://igaojin.me/2018/02/04/websocket与爬虫/3.jpg"><meta property="og:image" content="https://igaojin.me/2018/02/04/websocket与爬虫/4.jpg"><meta property="og:image" content="https://igaojin.me/2018/02/04/websocket与爬虫/5.jpg"><meta property="og:image" content="https://igaojin.me/2018/02/04/websocket与爬虫/6.jpg"><meta property="og:image" content="https://igaojin.me/2018/02/04/websocket与爬虫/7.jpg"><meta property="og:image" content="https://igaojin.me/2018/02/04/websocket与爬虫/8.jpg"><meta property="og:image" content="https://igaojin.me/2018/02/04/websocket与爬虫/9.jpg"><meta property="og:image" content="https://igaojin.me/2018/02/04/websocket与爬虫/10.jpg"><meta property="og:image" content="https://igaojin.me/2018/02/04/websocket与爬虫/11.jpg"><meta property="og:image" content="https://igaojin.me/2018/02/04/websocket与爬虫/12.jpg"><meta property="og:image" content="https://igaojin.me/2018/02/04/websocket与爬虫/13.jpg"><meta property="og:image" content="https://igaojin.me/2018/02/04/websocket与爬虫/14.jpg"><meta property="og:updated_time" content="2019-11-23T15:34:56.940Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="websocket与爬虫"><meta name="twitter:description" content="背景 写爬虫的目的应该就是为了拿到数据，或者说模拟某种操作 如果他使用的是http(s) 协议来传输数据的，那么我们就模拟http协议来发送数据 如果它使用的是websocket协议来传输数据的， 那么我们理所当然的就模拟websocket来发送数据~  首先，我们需要了解什么是websocket  websocket的介绍 WebSocket是一种在单个TCP连接上进行全双工通讯的协议。WebS"><meta name="twitter:image" content="https://igaojin.me/2018/02/04/websocket与爬虫/0.jpg"><link rel="alternate" href="/atom.xml" title="高金的博客" type="application/atom+xml"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/mycdn@2.0.0/static/css/style.min.css"><script type="text/javascript">!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject="ga",e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="//www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script"),ga("create","UA-113457160-1","auto"),ga("send","pageview")</script><script src="https://cdn.jsdelivr.net/gh/snaptortoise/konami-js@1.6.2/konami.min.js"></script><script>var easter_egg=new Konami("https://igaojin.me/buy-me-a-coffee/?find_a_egg")</script><script async src="https://rum.perfops.net/rum3.min.js"></script></head></html><body><div id="container"><div id="wrap"><header id="header"><div id="banner"></div><div id="header-outer" class="outer"><div id="header-inner" class="inner"><nav id="sub-nav"><a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a> <a id="nav-search-btn" class="nav-icon" title="搜索"></a></nav><div id="search-form-wrap"><form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://igaojin.me"></form></div><nav id="main-nav"><a id="main-nav-toggle" class="nav-icon"></a> <a class="main-nav-link" href="/">首页</a> <a class="main-nav-link" href="/archives">归档</a> <a class="main-nav-link" href="/qisimiaoxiang">奇思妙想</a> <a class="main-nav-link" href="/about">关于我</a> <a class="main-nav-link" href="/lab/">实验室</a> <a class="main-nav-link" href="/buy-me-a-coffee/">赞赏我</a></nav></div><div id="header-title" class="inner"><h1 id="logo-wrap"><a href="/" id="logo">高金的博客</a></h1></div></div></header><div class="outer"><section id="main"><article id="post-websocket与爬虫" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2018/02/04/websocket与爬虫/" class="article-date"><time datetime="2018-02-04T13:24:16.000Z" itemprop="datePublished">2018-02-04</time></a><div class="article-category"><a class="article-category-link" href="/categories/爬虫/">爬虫</a></div></div><div class="article-inner"><header class="article-header"><h1 class="article-title" itemprop="name">websocket与爬虫</h1></header><div class="article-entry" itemprop="articleBody"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>写爬虫的目的应该就是为了拿到数据，或者说模拟某种操作<br>如果他使用的是http(s) 协议来传输数据的，那么我们就模拟http协议来发送数据<br>如果它使用的是websocket协议来传输数据的，<br>那么我们理所当然的就模拟websocket来发送数据~</p><p>首先，我们需要了解什么是websocket</p><h2 id="websocket的介绍"><a href="#websocket的介绍" class="headerlink" title="websocket的介绍"></a>websocket的介绍</h2><blockquote><p>WebSocket是一种在单个TCP连接上进行全双工通讯的协议。WebSocket通信协议于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准。</p></blockquote><blockquote><p>WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p></blockquote><p>上面是维基百科的介绍.<br>简单的将，websocket 和http一样，都是一种网络传输协议</p><h3 id="他比http协议好的地址有哪些呢？"><a href="#他比http协议好的地址有哪些呢？" class="headerlink" title="他比http协议好的地址有哪些呢？"></a>他比http协议好的地址有哪些呢？</h3><ul><li>较少的控制开销。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10字节（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的掩码。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。</li><li>更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。</li><li>保持连接状态。于HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。</li><li>更好的二进制支持。Websocket定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容。</li><li>可以支持扩展。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等。</li><li>更好的压缩效果。相对于HTTP压缩，Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率</li></ul><h3 id="websocket的应用场景"><a href="#websocket的应用场景" class="headerlink" title="websocket的应用场景"></a>websocket的应用场景</h3><ul><li>直播平台的弹幕</li><li>实时聊天</li><li>等等</li></ul><h2 id="websocket-协议"><a href="#websocket-协议" class="headerlink" title="websocket 协议"></a>websocket 协议</h2><p>WebSocket 是独立的、创建在 TCP 上的协议。</p><p>Websocket 通过 HTTP/1.1 协议的101状态码进行握手。</p><p>为了创建Websocket连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为“握手”</p><p>那么websocket协议是如何握手的呢？</p><h3 id="websocket握手"><a href="#websocket握手" class="headerlink" title="websocket握手"></a>websocket握手</h3><p>下面是websocket一次握手的过程<br><strong>客户端请求</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Host: example.com</span><br><span class="line">Origin: http://example.com</span><br><span class="line">Sec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure><p></p><p><strong>服务器响应</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=</span><br><span class="line">Sec-WebSocket-Location: ws://example.com/</span><br></pre></td></tr></table></figure><p></p><p><strong>和http字段不一样的地方</strong></p><ul><li>Connection必须设置Upgrade，表示客户端希望连接升级。</li><li>Upgrade字段必须设置Websocket，表示希望升级到Websocket协议。</li><li>Sec-WebSocket-Key是随机的字符串，服务器端会用这些数据来构造出一个SHA-1的信息摘要。把“Sec-WebSocket-Key”加上一个特殊字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，然后计算SHA-1摘要，之后进行BASE-64编码，将结果做为“Sec-WebSocket-Accept”头的值，返回给客户端。如此操作，可以尽量避免普通HTTP请求被误认为Websocket协议。</li><li>Sec-WebSocket-Version 表示支持的Websocket版本。RFC6455要求使用的版本是13，之前草案的版本均应当弃用。</li><li>Origin字段是可选的，通常用来表示在浏览器中发起此Websocket连接所在的页面，类似于Referer。但是，与Referer不同的是，Origin只包含了协议和主机名称。</li><li>其他一些定义在HTTP协议中的字段，如Cookie等，也可以在Websocket中使用。</li></ul><p>可以看到只是在http协议上增加了几个硬性规定，http协议的user-agent,cookie都可以在websocket握手过程中使用</p><p><strong>抓包时候的注意事项:因为websocket只有一次握手，握手成功后就可以双方发送消息了，假如你打开网页后没有找到你要抓的数据，那么你就需要重新刷新网页，让他重新握手一次</strong></p><h2 id="websocket的事件"><a href="#websocket的事件" class="headerlink" title="websocket的事件"></a>websocket的事件</h2><h3 id="on-open"><a href="#on-open" class="headerlink" title="on_open"></a>on_open</h3><p>表示刚刚连接的时候</p><h3 id="onmessage"><a href="#onmessage" class="headerlink" title="onmessage"></a>onmessage</h3><p>表示收到消息怎么做</p><h3 id="send"><a href="#send" class="headerlink" title="send"></a>send</h3><p>表示给服务器发送消息</p><h3 id="on-close"><a href="#on-close" class="headerlink" title="on_close"></a>on_close</h3><p>表示关闭连接</p><p>那么知道了这些对我们有什么好处么?<br>找js的时候会很好找，这几个关键词基本上都是固定的<br>你可以直接全局搜搜,然后很容易能找到发送的js代码</p><p>模拟发送的时候也是一样的.</p><h2 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h2><p>前面介绍了一堆websocket协议相关的东西，估计很多人已经晕了.<br>没关系，先看实例，有问题再回到上面看</p><h3 id="抓包可以使用fiddle，chrome也是可以的"><a href="#抓包可以使用fiddle，chrome也是可以的" class="headerlink" title="抓包可以使用fiddle，chrome也是可以的"></a>抓包可以使用fiddle，chrome也是可以的</h3><p>我们先使用chrome</p><p>本次要抓的网站的<a href="http://www.10brandchina.com/vote/startin.php?id=41867" rel="external nofollow noopener noreferrer" target="_blank">一个投票网站</a><br>大家可以先随便投一个票，抓抓包看看<br>会发现怎么没有找到他是如何提交数据的…</p><p>选择ws,然后刷新下网页，再点击下投票，会发现有一个请求<br><img src="/2018/02/04/websocket与爬虫/0.jpg"></p><p>可以看到是在握手阶段,请求头里面的参数和我们上面讲的是一样的.</p><p>请求地址是<code>ws://v5.10brandchina.com:8008/</code><br>这边顺带说一下，有时候这边会看到 <code>wss://v5.10brandchina.com:8008/</code><br>那么这两个有啥区别的，简单的讲就是http与https协议的区别一样…<br><img src="/2018/02/04/websocket与爬虫/1.jpg"></p><p>看一下交互的内容（点击Frames）<br>可以看到已经有四条消息了，但是消息内容是二进制的，chrome这边无法预览…<br>那么我们使用fiddle试一下</p><img src="/2018/02/04/websocket与爬虫/2.jpg"><h3 id="抓包与分析"><a href="#抓包与分析" class="headerlink" title="抓包与分析"></a>抓包与分析</h3><p>打开fiddle，<strong>刷新一下网页</strong><br>不刷新的话是看不到的，然后随便投一下票.</p><img src="/2018/02/04/websocket与爬虫/3.jpg"><p>怎么找到请求呢，很简单，看状态码为101的就行，然后双击这一行</p><p>然后这边还是看到四条消息，我们点击第一条，然后用<code>TextView</code>展示，可以看到消息是这些<br>为啥用<code>TextView</code>呢？其实是一个一个的试过来的，假如你发现都试过了，还是乱码，那应该是他使用了其他的压缩或者加密方法，需要查看js看看他是如何加密的</p><img src="/2018/02/04/websocket与爬虫/4.jpg"><p>这个网站的数据是没有加密过的.<br>带向上的箭头的是我们向服务器发送的，向下的箭头是服务器返回的(下面的数据，前面带黑点？,是我们发送的)</p><ul><li><code>{&quot;action&quot;:&quot;auth&quot;,&quot;val&quot;:5}</code></li></ul><p><code>{&quot;action&quot;:&quot;auth&quot;,&quot;msg&quot;:&quot;eval(\&quot;\\115\\141\\164\\150\\56\\163\\151\\156\\50\\61\\65\\61\\67\\67\\66\\62\\63\\61\\63\\51\&quot;)&quot;}</code></p><ul><li><code>{&quot;action&quot;:&quot;auth&quot;,&quot;val&quot;:-0.3241458910493796}</code></li></ul><p><code>{&quot;action&quot;:&quot;wait&quot;,&quot;msg&quot;:95420}</code></p><ul><li><code>{&quot;action&quot;:&quot;vote&quot;,&quot;val&quot;:&quot;{\&quot;itemid\&quot;:126067,\&quot;catid\&quot;:41867,\&quot;captcha\&quot;:\&quot;%u7EC7%u65E7%u5F88%u9C7C\&quot;,\&quot;auth\&quot;:5,\&quot;rnd\&quot;:\&quot;4186712606754595\&quot;}&quot;}</code></li></ul><p><code>{&quot;action&quot;:&quot;vote&quot;,&quot;msg&quot;:&quot;ok,231812,2018-02-04 22:32:55&quot;}</code></p><p>可以看出来<br>首先我们发送<code>{&quot;action&quot;:&quot;auth&quot;,&quot;val&quot;:5}</code><br>然后服务器返回一串信息给我们,<br>然后我们根据服务器返回的算出一个值,也就是<br><code>{&quot;action&quot;:&quot;auth&quot;,&quot;val&quot;:-0.3241458910493796}</code><br>再发送给服务器.<br>服务器返回<code>{&quot;action&quot;:&quot;wait&quot;,&quot;msg&quot;:95420}</code>,表示验证通过<br>然后我们投票,发送了投票的一些信息给服务<br>服务器告诉我们投票成功.</p><p>以上就是整个通讯过程.</p><p>那如果我们要模拟发送的话，需要知道哪些信息呢</p><ol><li><code>{&quot;action&quot;:&quot;auth&quot;,&quot;val&quot;:5}</code>里面的<code>val:5</code>,这个5是固定的么？如果不是，是如何生成的</li><li>服务器返回的是什么，如何解析</li><li>如何根据服务器返回的生成一个新的val</li><li>发送投票信息里面<code>{&quot;action&quot;:&quot;vote&quot;,&quot;val&quot;:&quot;{\&quot;itemid\&quot;:126067,\&quot;catid\&quot;:41867,\&quot;captcha\&quot;:\&quot;%u7EC7%u65E7%u5F88%u9C7C\&quot;,\&quot;auth\&quot;:5,\&quot;rnd\&quot;:\&quot;4186712606754595\&quot;}&quot;}</code><br>itemid,catid,capthc,auth,rnd如何生成</li></ol><h2 id="找参数"><a href="#找参数" class="headerlink" title="找参数"></a>找参数</h2><p>还是使用chrome，直接用<code>ctrl + shift +f</code>，然后输入websocket（或者on_open,on_message，等等上面提到的事件去搜索）</p><p>运气很好，输入<code>websocket</code>直接就搜到了js,还是没有混淆的<br><img src="/2018/02/04/websocket与爬虫/5.jpg"></p><p>首先发现 websocket 地址是根据catId变的，如果catId能被2整除则地址为xxx，否则为xxx<br>那么catId是什么呢，调试发现就是url中的id，我们当前url为<code>http://www.10brandchina.com/vote/startin.php?id=41867</code>则 catId为<code>41867</code></p><p>然后onmessage也看到了，大概意思是收到信息后，用json解析，如果action是auth的话，则调用sendData这个方法，如果action是vote的话，则使用vote_resule方法.</p><img src="/2018/02/04/websocket与爬虫/6.jpg"><p>在看到onopen方法，是调用sendData,并发送<code>(&#39;auth&#39;,authType)</code>,在这边是不是联想到前面，我们第一次发送的数据？<code>{&quot;action&quot;:&quot;auth&quot;,&quot;val&quot;:5}</code>,是不是感觉一模一样</p><p>close方法就不说了,反正我们也用不上<br><img src="/2018/02/04/websocket与爬虫/7.jpg"></p><p>再看看sendData这个方法,<br><img src="/2018/02/04/websocket与爬虫/8.jpg"><br>用python实现的话是这样<img src="/2018/02/04/websocket与爬虫/9.jpg"></p><p>再看vote_result方法，大概作用是判断投票结果<br><img src="/2018/02/04/websocket与爬虫/10.jpg"></p><p>所有的方法我们都找到了，那么我们再和之前要找的参数走一遍.</p><ol><li><p><code>{&quot;action&quot;:&quot;auth&quot;,&quot;val&quot;:5}</code>里面的<code>val:5</code>,这个5是固定的么？如果不是，是如何生成的</p><p><strong>这个5也就是onopen里面的authType，至于authType是不是固定的，搜索一下就知道了.</strong></p></li><li><p>服务器返回的是什么，如何解析</p></li><li><p>如何根据服务器返回的生成一个新的val</p><p><strong>可以通过onmessage方法知道他返回的json数据，json解析一下就行，</strong><br><strong>里面的val是通过执行 <code>eval(val)</code>得到的</strong><br><strong>所以你也可以直接执行这个.或者用python实现</strong></p><img src="/2018/02/04/websocket与爬虫/11.jpg"></li><li><p>发送投票信息里面<code>{&quot;action&quot;:&quot;vote&quot;,&quot;val&quot;:&quot;{\&quot;itemid\&quot;:126067,\&quot;catid\&quot;:41867,\&quot;captcha\&quot;:\&quot;%u7EC7%u65E7%u5F88%u9C7C\&quot;,\&quot;auth\&quot;:5,\&quot;rnd\&quot;:\&quot;4186712606754595\&quot;}&quot;}</code><br>itemid,catid,capthc,auth,rnd如何生成</p></li></ol><p><strong>itemid 就是你投票的公司的id，catid之前讲过，captcha就是验证码,</strong><br><strong>auth和上面的authtype一样</strong><br><strong>rnd是通过搜索js发现了.</strong><br><img src="/2018/02/04/websocket与爬虫/12.jpg"></p><p>再看看验证码是如何生成的呢<br><img src="/2018/02/04/websocket与爬虫/13.jpg"></p><p>检查验证码是否正确<br><img src="/2018/02/04/websocket与爬虫/14.jpg"></p><p>我们已经拿到所有需要的东西了，只要用程序模拟发送就行了.</p><h2 id="模拟发送"><a href="#模拟发送" class="headerlink" title="模拟发送"></a>模拟发送</h2><p>使用的包是<a href="https://github.com/websocket-client/websocket-client/" rel="external nofollow noopener noreferrer" target="_blank">websocket</a></p><p>官方demo<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> websocket</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> thread</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">import</span> _thread <span class="keyword">as</span> thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span><span class="params">(ws, message)</span>:</span></span><br><span class="line">    print(message)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_error</span><span class="params">(ws, error)</span>:</span></span><br><span class="line">    print(error)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_close</span><span class="params">(ws)</span>:</span></span><br><span class="line">    print(<span class="string">"### closed ###"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_open</span><span class="params">(ws)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(*args)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            ws.send(<span class="string">"Hello %d"</span> % i)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        ws.close()</span><br><span class="line">        print(<span class="string">"thread terminating..."</span>)</span><br><span class="line">    thread.start_new_thread(run, ())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    websocket.enableTrace(<span class="literal">True</span>)</span><br><span class="line">    ws = websocket.WebSocketApp(<span class="string">"ws://echo.websocket.org/"</span>,</span><br><span class="line">                              on_message = on_message,</span><br><span class="line">                              on_error = on_error,</span><br><span class="line">                              on_close = on_close)</span><br><span class="line">    ws.on_open = on_open</span><br><span class="line">    ws.run_forever()</span><br></pre></td></tr></table></figure><p></p><p>可以看到使用还是很简单的，也是<code>onopen,onmessage,send</code></p><p>所以我们只要用我们上面得到的信息就行模拟发送就可以了</p><p>因为是投票网站，所以不提供代码…有啥问题，请留言~</p><p><br><strong>本文作者</strong>：高金<br><strong>本文地址</strong>： <a href="https://igaojin.me/2018/02/04/websocket与爬虫/">https://igaojin.me/2018/02/04/websocket与爬虫/</a><br><strong>版权声明</strong>：转载请注明出处！</p></div><footer class="article-footer"><a data-url="https://igaojin.me/2018/02/04/websocket与爬虫/" data-id="ck96regek002oywypx1emomyg" class="article-share-link">分享</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/websocket/">websocket</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/websocket抓包/">websocket抓包</a></li></ul></footer></div><script src="https://cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><div id="random_posts"><h2>推荐文章</h2><div class="random_posts_ul"><script>var random_count=4,site={BASE_URI:"/"};function load_random_posts(t){var s=site.posts;if(t){for(var o,r,a=s.length;a;o=Math.floor(Math.random()*a),r=s[--a],s[a]=s[o],s[o]=r);s=s.slice(0,random_count);for(var e="<ul>",n=0;n<s.length;n++){var i=s[n];e+="<li><strong>"+i.date+':&nbsp;&nbsp;<a href="'+(site.BASE_URI+i.uri)+'">'+(i.title||i.uri)+"</a></strong>",i.excerpt&&(e+='<div class="post-excerpt">'+i.excerpt+"</div>"),e+="</li>"}$(t).html(e+"</ul>")}}$(".random_posts_ul").each(function(){var s=this;site.posts&&site.posts.length?load_random_posts(s):$.getJSON(site.BASE_URI+"js/posts.js",function(t){site.posts=t,load_random_posts(s)})})</script></div></div><nav id="article-nav"><a href="/2018/02/08/佛性编程/" id="article-nav-newer" class="article-nav-link-wrap"><strong class="article-nav-caption">上一篇</strong><div class="article-nav-title">佛系编程[如何创建一个安全可靠的应用程序]</div></a><a href="/2018/02/03/github如何创建ssh-key/" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">下一篇</strong><div class="article-nav-title">github如何创建ssh-key</div></a></nav></article><div class="comments" id="comments"><div id="gitment_comments"></div></div></section><aside id="sidebar"><div class="widget-wrap"><div class="widget" id="toc-widget-fixed"><strong class="toc-title">文章目录</strong><div class="toc-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#背景"><span class="toc-number">1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#websocket的介绍"><span class="toc-number">2.</span> <span class="toc-text">websocket的介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#他比http协议好的地址有哪些呢？"><span class="toc-number">2.1.</span> <span class="toc-text">他比http协议好的地址有哪些呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#websocket的应用场景"><span class="toc-number">2.2.</span> <span class="toc-text">websocket的应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#websocket-协议"><span class="toc-number">3.</span> <span class="toc-text">websocket 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#websocket握手"><span class="toc-number">3.1.</span> <span class="toc-text">websocket握手</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#websocket的事件"><span class="toc-number">4.</span> <span class="toc-text">websocket的事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#on-open"><span class="toc-number">4.1.</span> <span class="toc-text">on_open</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#onmessage"><span class="toc-number">4.2.</span> <span class="toc-text">onmessage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#send"><span class="toc-number">4.3.</span> <span class="toc-text">send</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#on-close"><span class="toc-number">4.4.</span> <span class="toc-text">on_close</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实际案例"><span class="toc-number">5.</span> <span class="toc-text">实际案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#抓包可以使用fiddle，chrome也是可以的"><span class="toc-number">5.1.</span> <span class="toc-text">抓包可以使用fiddle，chrome也是可以的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抓包与分析"><span class="toc-number">5.2.</span> <span class="toc-text">抓包与分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#找参数"><span class="toc-number">6.</span> <span class="toc-text">找参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模拟发送"><span class="toc-number">7.</span> <span class="toc-text">模拟发送</span></a></li></ol></div></div></div></aside></div><footer id="footer"><div class="outer"><div id="footer-left">&copy; 2014 - 2020 Gao JIn&nbsp;|&nbsp; 主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank" rel="external nofollow noopener noreferrer">Cafe</a></div><div id="footer-right">联系方式&nbsp;|&nbsp; i@igaojin.me</div></div></footer><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script></div><nav id="mobile-nav"><a href="/" class="mobile-nav-link">首页</a> <a href="/archives" class="mobile-nav-link">归档</a> <a href="/qisimiaoxiang" class="mobile-nav-link">奇思妙想</a> <a href="/about" class="mobile-nav-link">关于我</a> <a href="/lab/" class="mobile-nav-link">实验室</a> <a href="/buy-me-a-coffee/" class="mobile-nav-link">赞赏我</a></nav><img class="back-to-top-btn" src="/images/fly-to-top.png"><script>window.onload=function(){new Elevator({selector:".back-to-top-btn",element:document.querySelector(".back-to-top-btn"),duration:1e3})}</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitment@0.0.3/style/default.css"><script src="//cdn.jsdelivr.net/npm/gitment@0.0.3/dist/gitment.browser.js"></script><script>var gitment=new Gitment({id:"Sun Feb 04 2018 21:24:16 GMT+0800",owner:"jin10086",repo:"jin10086.github.io",oauth:{client_id:"935e92a5333436856348",client_secret:"e655566eaf920d216ec6283978d67874bf0850a6"}});gitment.render(document.getElementById("gitment_comments"))</script><script src="//cdn.jsdelivr.net/npm/mycdn@2.0.0/static/js/is.js"></script><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.5/jquery.fancybox.min.css"><script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script src="//cdn.jsdelivr.net/npm/mycdn@2.0.0/static/js/script.js"></script><script src="//cdn.jsdelivr.net/npm/mycdn@2.0.0/static/js/elevator.js"></script></div></body>