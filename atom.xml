<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>高金的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jin10086.github.io/"/>
  <updated>2018-04-25T08:03:55.997Z</updated>
  <id>https://jin10086.github.io/</id>
  
  <author>
    <name>Gao JIn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>黑客已经盗了15,945,221.72 USD</title>
    <link href="https://jin10086.github.io/2018/04/25/%E9%BB%91%E5%AE%A2%E5%B7%B2%E7%BB%8F%E7%9B%97%E4%BA%8615-945-221-72-USD/"/>
    <id>https://jin10086.github.io/2018/04/25/黑客已经盗了15-945-221-72-USD/</id>
    <published>2018-04-25T08:03:11.000Z</published>
    <updated>2018-04-25T08:03:55.997Z</updated>
    
    <content type="html"><![CDATA[<h2 id="黑客已经盗了15-945-221-72-USD"><a href="#黑客已经盗了15-945-221-72-USD" class="headerlink" title="黑客已经盗了15,945,221.72 USD"></a>黑客已经盗了15,945,221.72 USD</h2><p>myetherwallet 昨日发推特说，他们的DNS 被污染，导致部分用户进入到了假的 网站，从而导致ETH被盗</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqox4nbpl4j20yy0lq0xl.jpg" alt=""></p><p>截止到今天（2018-04-25 15:00) 黑客已经累计盗取了24,130.543323767777777777 Ether</p><p>换算成美元大概 $15,945,221.72 (@ $660.79/ETH)</p><p>这还没有包括 $143,924.09 的代币</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqox8zeu82j20r40p0ju6.jpg" alt=""></p><p>本文发出的时候，黑客账号还持续进账！！！</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqox5i91o0j21xq18itqh.jpg" alt=""></p><p> <a href="https://etherscan.io/address/0xb3aaaae47070264f3595c5032ee94b620a583a39" rel="external nofollow noopener noreferrer" target="_blank">黑客的钱包地址</a></p><h2 id="一些网友在该账户下面的评论"><a href="#一些网友在该账户下面的评论" class="headerlink" title="一些网友在该账户下面的评论"></a>一些网友在该账户下面的评论</h2><p> <img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqoxb4i56hj21we0tugtm.jpg" alt=""></p><p> <img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqoxc5pb13j21we0ocwml.jpg" alt=""></p><p> 还有一些人在乘机诈骗<br> <img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqoxe3ykbpj21ww0emwil.jpg" alt=""></p><p> 还有一些很可怜的人…</p><p> <img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqoxejlpp1j215606iq46.jpg" alt=""></p><p> 更多评论在<a href="https://etherscan.io/address/0xb3aaaae47070264f3595c5032ee94b620a583a39#comments" rel="external nofollow noopener noreferrer" target="_blank">0xb3aaaae47070264f3595c5032ee94b620a583a39</a></p><h2 id="什么是DNS欺骗"><a href="#什么是DNS欺骗" class="headerlink" title="什么是DNS欺骗"></a>什么是DNS欺骗</h2><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><blockquote><p>举一个例子，zh.wikipedia.org作为一个域名就和IP地址208.80.154.225相对应。DNS就像是一个自动的电话号码簿，我们可以直接拨打wikipedia的名字来代替电话号码（IP地址）。DNS在我们直接调用网站的名字以后就会将像zh.wikipedia.org一样便于人类使用的名字转化成像208.80.154.225一样便于机器识别的IP地址。</p></blockquote><blockquote><p>DNS查询有两种方式：递归和迭代。DNS客户端设置使用的DNS服务器一般都是递归服务器，它负责全权处理客户端的DNS查询请求，直到返回最终结果。而DNS服务器之间一般采用迭代查询方式。</p></blockquote><blockquote><p>以查询zh.wikipedia.org为例：</p></blockquote><blockquote><p>客户端发送查询报文”query zh.wikipedia.org”至DNS服务器，DNS服务器首先检查自身缓存，如果存在记录则直接返回结果。<br>如果记录老化或不存在，则<br>DNS服务器向根域名服务器发送查询报文”query zh.wikipedia.org”，根域名服务器返回.org域的权威域名服务器地址，这一级首先会返回的是顶级域名的权威域名服务器。<br>DNS服务器向.org域的权威域名服务器发送查询报文”query zh.wikipedia.org”，得到.wikipedia.org域的权威域名服务器地址。<br>DNS服务器向.wikipedia.org域的权威域名服务器发送查询报文”query zh.wikipedia.org”，得到主机zh的A记录，存入自身缓存并返回给客户端。</p></blockquote><p>简单的讲 就是:</p><p>假如我今天要打开百度</p><ul><li>那我先在浏览器输入 <a href="https://www.baidu.com" rel="external nofollow noopener noreferrer" target="_blank">https://www.baidu.com</a></li><li>然后 首先会检查我本地的dns 缓存,看看知不知道 百度的 ip是多少,如果已经知道的话，则返回给我，那么最终我访问的是 这个ip（所以 在 <a href="https://www.baidu.com" rel="external nofollow noopener noreferrer" target="_blank">https://www.baidu.com</a> == 返回给我的ip </li><li>如果不知道的话，则继续问上一层dns服务器，直到问到为止！</li></ul><p>那么<strong>dns欺骗</strong>是咋回事呢？</p><p>假如我今天要打开百度<br>我问dns 服务器，百度的ip是多少(假如正确的是 115.239.210.27)<br>但是dns服务器告诉我，百度的ip是 192.168.2.221</p><p>那么我实际打开的也就是 192.168.2.221</p><p>而这台服务器也做了个和百度一模一样的页面，那么我是不知道我被骗了！！！</p><p>然后我再百度页 提交的任何东西，都被黑客知道了。。。</p><h3 id="本次事件"><a href="#本次事件" class="headerlink" title="本次事件"></a>本次事件</h3><p><img src="https://blog.cloudflare.com/content/images/2018/04/Slide1.png" alt=""></p><p><img src="https://blog.cloudflare.com/content/images/2018/04/Slide2.png" alt=""></p><p>已经有人画了两张图，很清楚的描述了具体情况</p><h2 id="那么我们如何避免这种情况呢？"><a href="#那么我们如何避免这种情况呢？" class="headerlink" title="那么我们如何避免这种情况呢？"></a>那么我们如何避免这种情况呢？</h2><ul><li><p>在<a href="https://www.myetherwallet.com" rel="external nofollow noopener noreferrer" target="_blank">https://www.myetherwallet.com</a> 上转账的时候，一定要确保域名 以及HTTPS证书是正确的！！！</p><p>  <strong>如下图，不是绿色的，一定不要在上面输入任何信息…</strong><br>  其实不管是任何网站，一定要看到颜色是绿色的！（表示证书被验证通过了）<br>  <img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqoy8u5c4mj20vc036758.jpg" alt=""></p><p>  如下这种情况，表示证书有问题（本次myetherwallet有弹出这个）<br>  如果你还点继续的话，那么只能说你 <strong>人傻钱多了</strong><br>  <img src="https://blog.cloudflare.com/content/images/2018/04/Screen-Shot-2018-04-24-at-1.55.12-PM.png" alt=""></p></li><li><p>在联网情况下，不要输入私钥！！！<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqoyioozdkj225e0rwdnn.jpg" alt=""></p></li></ul><p>要使用钱包的话，推荐使用metamask！！！</p><p>本次的话，如果你就算打开了钓鱼网站，只要你没有在网站上输入 私钥，而是用metamask的话，那么你的钱暂时还是安全的）</p><ul><li>如果一定要用私钥的话，一定要在断网环境!!!</li></ul><p><strong>最后，花上几分钟阅读 <a href="https://myetherwallet.github.io/knowledge-base/security/" rel="external nofollow noopener noreferrer" target="_blank">https://myetherwallet.github.io/knowledge-base/security/</a></strong></p><p><strong>如果是电脑小白的话，推荐使用硬体钱包！别在网上乱买！</strong></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.cloudflare.com/bgp-leaks-and-crypto-currencies/" rel="external nofollow noopener noreferrer" target="_blank">https://blog.cloudflare.com/bgp-leaks-and-crypto-currencies/</a><br><a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F" rel="external nofollow noopener noreferrer" target="_blank">https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F</a></p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      黑客已经盗了15,945,221.72 USD
myetherwallet 昨日发推特说，他们的DNS 被污染，导致部分用户进入到了假的 网站，从而导致ETH被盗



截止到今天（2018-04-25 15:00) 黑客已经累计盗取了24,130.543323767777777777 Ether

换算成美元大概 $15,945,221.72 (@ $660.79/ETH)

这还没有包括 $143,924.09 的代币



本文发出的时候，黑客账号还持续进账！！！



 黑客的钱包地址

一些网友在该账户下面的评论
 

 

 还有一些人在乘机诈骗


 还有一些很可怜的人…

 

    
    </summary>
    
      <category term="区块链" scheme="https://jin10086.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="黑客" scheme="https://jin10086.github.io/tags/%E9%BB%91%E5%AE%A2/"/>
    
      <category term="安全" scheme="https://jin10086.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="myetherwallet" scheme="https://jin10086.github.io/tags/myetherwallet/"/>
    
  </entry>
  
  <entry>
    <title>一键上链</title>
    <link href="https://jin10086.github.io/2018/04/25/%E4%B8%80%E9%94%AE%E4%B8%8A%E9%93%BE/"/>
    <id>https://jin10086.github.io/2018/04/25/一键上链/</id>
    <published>2018-04-25T06:24:54.000Z</published>
    <updated>2018-04-26T06:46:38.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一键上链！"><a href="#一键上链！" class="headerlink" title="一键上链！"></a>一键上链！</h2><p>今天在朋友圈看到很多人在 讨论 <strong>北大yuexin上链</strong>事件.</p><p>虽然看到很多人写了教程 如何上链，但是觉得对普通人门槛还是太高了！</p><p>所以 做了一个一键上链的服务！</p><p>请直接点击&gt;&gt;&gt;<a href="http://www.dapdap.io/#/onChain" rel="external nofollow noopener noreferrer" target="_blank">一键上链</a></p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqo7ukywt7j20v00u07ij.jpg" alt=""></p><p>在文本框内输入你要上链的内容，然后点击提交即可！！！</p><p>成功后会看到如下内容，点击以太坊交易流水号.</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqo80hyhw8j21yq08wgn9.jpg" alt=""></p><p>页面拉到最下面，点击<em>convert to UTF8</em>，则可以在看到你上链的内容了！</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqomrevja2j21xm14y4bp.jpg" alt=""></p><p>如果还不明白的，我们做了一个动图！</p><p><img src="http://wx3.sinaimg.cn/mw690/cfc08357gy1fqq22c26a6g20bi0kg4nk.gif" alt=""></p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      一键上链！
今天在朋友圈看到很多人在 讨论 北大yuexin上链事件.

虽然看到很多人写了教程 如何上链，但是觉得对普通人门槛还是太高了！

所以 做了一个一键上链的服务！

请直接点击&gt;&gt;&gt;一键上链



在文本框内输入你要上链的内容，然后点击提交即可！！！

成功后会看到如下内容，点击以太坊交易流水号.



页面拉到最下面，点击convert to UTF8，则可以在看到你上链的内容了！



如果还不明白的，我们做了一个动图！
    
    </summary>
    
      <category term="区块链" scheme="https://jin10086.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="dapdap" scheme="https://jin10086.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/dapdap/"/>
    
    
  </entry>
  
  <entry>
    <title>一行代码蒸发了¥6,447,277,680人民币！</title>
    <link href="https://jin10086.github.io/2018/04/22/%E4%BA%BA%E6%B0%91%E5%B8%81%EF%BC%81/"/>
    <id>https://jin10086.github.io/2018/04/22/人民币！/</id>
    <published>2018-04-22T15:24:05.000Z</published>
    <updated>2018-04-22T15:25:14.525Z</updated>
    
    <content type="html"><![CDATA[<p><strong>现在进入你还是先行者，最后观望者进场才是韭菜。</strong></p><p>美图董事长蔡文胜曾在三点钟群，高调的说出了这句话，随即被大众疯传。</p><p>在他发表完言论没多久，2月美链（BEC）上交易所会暴涨4000%，后又暴跌。尽管他多次否认，聪明的网友早已扒出，他与BEC千丝万缕的关系。</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqltga6j8bj20hs0dpqas.jpg" alt=""></p><p>庄家坐庄操控币价，美图的股价随之暴涨，蔡文胜顺利完成了他的韭菜收割大计。</p><p>但在币圈，割人者，人恒割之。</p><p>随着BEC智能合约的漏洞的爆出，被黑客利用，瞬间套现抛售大额BEC，6亿在瞬间归零。</p><p>而这一切，竟然是因为一个简单至极的程序Bug。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天有人在群里说，<a href="https://etherscan.io/address/0xc5d105e63711398af9bbff092d4b6769c82f793d" rel="external nofollow noopener noreferrer" target="_blank">Beauty Chain 美蜜</a> 代码里面有bug，已经有人利用该bug获得了  57,896,044,618,658,100,000,000,000,000,000,000,000,000,000,000,000,000,000,000.792003956564819968 个 BEC</p><p>那笔操作记录是 <a href="https://etherscan.io/tx/0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660f" rel="external nofollow noopener noreferrer" target="_blank">0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660f</a></p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqlpon57s4j21qe15c13c.jpg" alt=""></p><p>下面我来带大家看看，黑客是如何实现的！</p><p>我们可以看到执行的方法是 <code>batchTransfer</code></p><p>那这个方法是干嘛的呢？（给指定的几个地址，发送相同数量的代币）</p><h3 id="整体逻辑是"><a href="#整体逻辑是" class="headerlink" title="整体逻辑是"></a>整体逻辑是</h3><p>你传几个地址给我(_receivers),然后再传给我你要给每个人多少代币（_value)</p><p>然后你要发送的总金额 = 发送的人数* 发送的金额</p><p>然后 要求你当前的余额大于 发送的总金额</p><p>然后扣掉你发送的总金额</p><p>然后 给_receivers 里面的每个人发送 指定的金额（_value)</p><p>从逻辑上看，这边是没有任何问题的，你想给别人发送代币，那么你本身的余额一定要大于发送的总金额的！</p><p>但是这段代码却犯了一个很傻的错!</p><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqlpsliqg9j21aq0di41a.jpg" alt=""></p><p>这个方法会传入两个参数</p><ol><li>_receivers</li><li>_value</li></ol><p>_receivers 的值是个列表，里面有两个地址 </p><p><a href="https://etherscan.io/token/0xc5d105e63711398af9bbff092d4b6769c82f793d?a=0x0e823ffe018727585eaf5bc769fa80472f76c3d7" rel="external nofollow noopener noreferrer" target="_blank">0x0e823ffe018727585eaf5bc769fa80472f76c3d7</a></p><p><a href="https://etherscan.io/token/0xc5d105e63711398af9bbff092d4b6769c82f793d?a=0xb4d30cac5124b46c2df0cf3e3e1be05f42119033" rel="external nofollow noopener noreferrer" target="_blank">0xb4d30cac5124b46c2df0cf3e3e1be05f42119033</a></p><p>_value 的值是 <code>8000000000000000000000000000000000000000000000000000000000000000</code></p><p>我们再查看代码（如下图）</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqlpj1qxlxj226s0o8wjw.jpg" alt=""></p><p>我们一行一行的来解释</p><p><code>uint cnt = _receivers.length;</code></p><p>是获取 _receivers 里面有几个地址，我们从上面可以看到 参数里面只有两个地址，所以 cnt=2，也就是 给两个地址发送代币</p><p><code>uint256 amount = uint256(cnt) * _value;</code></p><h2 id="uint256"><a href="#uint256" class="headerlink" title="uint256"></a>uint256</h2><p>首先<code>uint256(cnt)</code> 是把cnt 转成了 uint256类型</p><p>那么,什么是uint256类型？或者说uint256类型的取值范围是多少…</p><p>uintx 类型的取值范围是 0 到 2的x次方 -1</p><p>也就是 假如是 uint8的话 </p><p>则 uint8的取值范围是 0 到 2的8次方 -1 </p><p>也就是 0 到255</p><p>那么uint256 的取值范围是 </p><p>0 - 2的256次方-1  也就是 <code>0 到115792089237316195423570985008687907853269984665640564039457584007913129639935</code></p><p>python 算 2的256次方是多少<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqlpjvwod1j20zs03c74x.jpg" alt=""></p><p>那么假如说 设置的值超过了 取值范围怎么办？这种情况称为<code>溢出</code></p><p>举个例子来说明</p><p>因为uint256的取值太大了，所以用uint8来 举例。。。</p><p>从上面我们已经知道了  uint8 最小是0，最大是255</p><p>那么当我 255 + 1 的时候，结果是啥呢？<strong>结果会变成0</strong></p><p>那么当我 255 + 2 的时候，结果是啥呢？<strong>结果会变成1</strong></p><p>那么当我 0 - 1  的时候，结果是啥呢？<strong>结果会变成255</strong></p><p>那么当我 0 - 2  的时候，结果是啥呢？<strong>结果会变成255</strong></p><p>那么 我们回到上面的代码中，</p><p><code>amount = uint256(cnt) * _value</code></p><p>则 amount = 2* _value</p><p>但是此时 _value 是16进制的，我们把他转成 10进制 </p><p>（python 16进制转10进制）<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqlqm9j1thj20y203sjs6.jpg" alt=""></p><p>可以看到 _value = <code>57896044618658097711785492504343953926634992332820282019728792003956564819968</code></p><p>那么amount = _value*2 = <code>115792089237316195423570985008687907853269984665640564039457584007913129639936</code></p><p>可以在查看上面看到 uint256取值范围最大为 <code>115792089237316195423570985008687907853269984665640564039457584007913129639935</code></p><p>此时，amout已经超过了最大值，溢出 则<code>amount = 0</code></p><p>下一行代码<br><code>require(cnt &gt; 0 &amp;&amp; cnt &lt;= 20);</code><br>require 语句是表示该语句一定要是正确的，也就是 cnt 必须大于0 且 小于等于20</p><p>我们的cnt等于2，通过!</p><p><code>require(_value &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount);</code></p><p>这句要求 _value 大于0，我们的_value是大于0 的<br>且,当前用户拥有的代币余额大于等于 amount,因为amount等于0，所以 就算你一个代币没有，也是满足的！</p><p><code>balances[msg.sender] = balances[msg.sender].sub(amount);</code></p><p>这句是当前用户的余额 - amount</p><p>当前amount 是0，所以当前用户代币的余额没有变动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (uint i = 0; i &lt; cnt; i++) &#123;</span><br><span class="line">    balances[_receivers[i]] = balances[_receivers[i]].add(_value);</span><br><span class="line">    Transfer(msg.sender, _receivers[i], _value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这句是遍历 _receivers中的地址，<br>对每个地址做以下操作</p><p><code>balances[_receivers[i]] = balances[_receivers[i]].add(_value);</code><br>_receivers中的地址 的余额 = 原本余额+value</p><p>所以 _receivers 中地址的余额 则加了57896044618658097711785492504343953926634992332820282019728792003956564819968 个代币！！！</p><p><code>Transfer(msg.sender, _receivers[i], _value);}</code><br>这句则只是把赠送代币的记录存下来！！！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>就一个简单的溢出漏洞，导致BEC代币的市值接近归0</p><p>那么，开发者有没有考虑到溢出问题呢？</p><p>其实他考虑了,</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqlssg2452j225m0o20y4.jpg" alt=""></p><p>可以看如上截图</p><p>除了amount的计算外, 其他的给用户转钱 都用了safeMath 的方法（sub,add)</p><p>那么 为啥就偏偏这一句没有用safeMath的方法呢。。。</p><p>这就要用写代码的人了。。。</p><h2 id="啥是safeMath"><a href="#啥是safeMath" class="headerlink" title="啥是safeMath"></a>啥是safeMath</h2><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqlsweul1oj21o014k105.jpg" alt=""></p><p>safeMath 是为了计算安全 而写的一个library</p><p>我们看看他干了啥？为啥能保证计算安全.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function mul(uint256 a, uint256 b) internal constant returns (uint256) &#123;</span><br><span class="line">uint256 c = a * b;</span><br><span class="line">assert(a == 0 || c / a == b);</span><br><span class="line">return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面的乘法.<br>他在计算后，用assert 验证了下结果是否正确！</p><p>如果在上面计算 amount的时候，用了 mul的话，<br>则 <code>c / a == b</code><br>也就是 验证 amount / cnt == _value </p><p>这句会执行报错的，因为 0 / cnt  不等于 _value</p><p>所以程序会报错！</p><p>也就不会发生溢出了…</p><p>那么 还有一个小问题，这里的<code>assert</code> 好 <code>require</code> 好像是干的同一件事</p><p>都是为了验证 某条语句是否正确！</p><p>那么他俩有啥区别呢？</p><p> 用了assert的话，则程序的gas limit 会消耗完毕</p><p>而require的话，则只是消耗掉当前执行的gas </p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>那么 我们如何避免这种问题呢？</p><p>我个人看法是</p><ol><li>只要涉及到计算，一定要用safeMath</li><li>代码一定要测试！</li><li>代码一定要review！</li><li>必要时，要请专门做代码审计的公司来 测试代码</li></ol><p>这件事后需要如何处理呢？</p><p>目前，该方法已经暂停了（还好可以暂停）所以看过文章的朋友 不要去测试了…</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqltbqvtz7j227o0pyq8i.jpg" alt=""></p><p>不过已经发生了的事情咋办呢？</p><p>我的想法是，快照在漏洞之前，所有用户的余额情况</p><p>然后发行新的token，给之前的用户 发送等额的代币…</p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      现在进入你还是先行者，最后观望者进场才是韭菜。

美图董事长蔡文胜曾在三点钟群，高调的说出了这句话，随即被大众疯传。

在他发表完言论没多久，2月美链（BEC）上交易所会暴涨4000%，后又暴跌。尽管他多次否认，聪明的网友早已扒出，他与BEC千丝万缕的关系。



庄家坐庄操控币价，美图的股价随之暴涨，蔡文胜顺利完成了他的韭菜收割大计。

但在币圈，割人者，人恒割之。

随着BEC智能合约的漏洞的爆出，被黑客利用，瞬间套现抛售大额BEC，6亿在瞬间归零。

而这一切，竟然是因为一个简单至极的程序Bug。

背景
今天有人在群里说，Beauty Chain 美蜜 代码里面有bug，已经有人利用该
    
    </summary>
    
    
      <category term="区块链" scheme="https://jin10086.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>爬虫带你发现区块链好游戏</title>
    <link href="https://jin10086.github.io/2018/03/22/%E5%B8%A6%E4%BD%A0%E5%8F%91%E7%8E%B0%E5%A5%BD%E6%B8%B8%E6%88%8F/"/>
    <id>https://jin10086.github.io/2018/03/22/带你发现好游戏/</id>
    <published>2018-03-22T10:38:43.000Z</published>
    <updated>2018-04-04T07:12:10.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为啥做这个"><a href="#为啥做这个" class="headerlink" title="为啥做这个?"></a>为啥做这个?</h2><p><a href="https://zhuanlan.zhihu.com/p/34356844" rel="external nofollow noopener noreferrer" target="_blank">花了600万玩区块链游戏，我觉得智能合约还是有点靠谱的</a></p><p>要从这篇文章说起，之前帮nick拿数据的时候，就在想。既然 eth的所有数据都是公开的，那我是不是可以把所有的链上游戏的交易数据都拿下来，然后看看，</p><h3 id="针对所有游戏来说"><a href="#针对所有游戏来说" class="headerlink" title="针对所有游戏来说"></a>针对所有游戏来说</h3><ul><li>有多少人玩了区块链游戏？</li><li>有多少人赚了钱？</li><li>有多少人亏了钱？</li></ul><h3 id="针对某款游戏来说"><a href="#针对某款游戏来说" class="headerlink" title="针对某款游戏来说"></a>针对某款游戏来说</h3><p>有多少人玩过？<br>每天的日活是多少？<br>有多少人赚了钱？<br>有多少人亏了钱？</p><p>通过这些数据，那么我也就能分析出来</p><h1 id="这款游戏我现在玩能赚到钱么？"><a href="#这款游戏我现在玩能赚到钱么？" class="headerlink" title="这款游戏我现在玩能赚到钱么？"></a>这款游戏我现在玩能赚到钱么？</h1><h1 id="哪些游戏可能有猫腻？"><a href="#哪些游戏可能有猫腻？" class="headerlink" title="哪些游戏可能有猫腻？"></a>哪些游戏可能有猫腻？</h1><h1 id="哪些游戏一玩就亏钱？"><a href="#哪些游戏一玩就亏钱？" class="headerlink" title="哪些游戏一玩就亏钱？"></a>哪些游戏一玩就亏钱？</h1><h1 id="甚至还可以跟踪大佬（也就是赚钱最多的人"><a href="#甚至还可以跟踪大佬（也就是赚钱最多的人" class="headerlink" title="甚至还可以跟踪大佬（也就是赚钱最多的人)"></a>甚至还可以跟踪大佬（也就是赚钱最多的人)</h1><p>看看他在玩什么.</p><p>这样我们就可以愉快的”玩游戏”了</p><h2 id="Just-do-it"><a href="#Just-do-it" class="headerlink" title="Just do it!"></a>Just do it!</h2><p>有想法以后，一直想着赶快做出来…<br>然而我是个前端渣渣…<br>到哪里去找人一起来做呢？？？</p><p>刚好看到dorahack在西安举行hackthon.<br>就赶过去了，找到了一帮小伙伴一起把他完成了！</p><h2 id="网站演示"><a href="#网站演示" class="headerlink" title="网站演示"></a>网站演示</h2><p>网址在这&gt;&gt;&gt;<a href="http://www.dapdap.io/#/" rel="external nofollow noopener noreferrer" target="_blank">dapdap</a></p><p>查看所有dapp的情况<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fplswqo4awj211y0hpmz7.jpg" alt=""></p><p>查看某个游戏的收益情况<br><img src="http://ww1.sinaimg.cn/large/cfc08357ly1fplsy6022yj211y0hp75p.jpg" alt=""></p><p>查看某个游戏的收益情况（这是我的…<br><img src="http://ww1.sinaimg.cn/large/cfc08357ly1fplsz2rifyj211y0hpwfw.jpg" alt=""></p><p>某个游戏的用户情况<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fplt44ot0gj20uw0g7gmo.jpg" alt=""></p><h2 id="反馈与交流"><a href="#反馈与交流" class="headerlink" title="反馈与交流"></a>反馈与交流</h2><p>对这个网站有任何建议与吐槽的，欢迎加群！<br>想一起来玩区块链游戏的，欢迎加群讨论！<br>加群请扫描下面二维码<br>或者搜索718944415，加入！<br><img src="http://ww1.sinaimg.cn/large/cfc08357ly1fpltwfteelj206c07n0tf.jpg" alt=""><br>最后，网址是，<a href="http://www.dapdap.io" rel="external nofollow noopener noreferrer" target="_blank">http://www.dapdap.io</a></p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      为啥做这个?
花了600万玩区块链游戏，我觉得智能合约还是有点靠谱的

要从这篇文章说起，之前帮nick拿数据的时候，就在想。既然 eth的所有数据都是公开的，那我是不是可以把所有的链上游戏的交易数据都拿下来，然后看看，

针对所有游戏来说
 * 有多少人玩了区块链游戏？
 * 有多少人赚了钱？
 * 有多少人亏了钱？

针对某款游戏来说
有多少人玩过？
每天的日活是多少？
有多少人赚了钱？
有多少人亏了钱？

通过这些数据，那么我也就能分析出来

这款游戏我现在玩能赚到钱么？
哪些游戏可能有猫腻？
哪些游戏一玩就亏钱？
甚至还可以跟踪大佬（也就是赚钱最多的人)
看看他在玩什么.

这样我们就
    
    </summary>
    
      <category term="dapp" scheme="https://jin10086.github.io/categories/dapp/"/>
    
    
      <category term="以太坊" scheme="https://jin10086.github.io/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="dapdap.io" scheme="https://jin10086.github.io/tags/dapdap-io/"/>
    
  </entry>
  
  <entry>
    <title>知乎看图插件</title>
    <link href="https://jin10086.github.io/2018/03/06/%E7%9F%A5%E4%B9%8E%E7%9C%8B%E5%9B%BE%E6%8F%92%E4%BB%B6/"/>
    <id>https://jin10086.github.io/2018/03/06/知乎看图插件/</id>
    <published>2018-03-06T15:59:48.000Z</published>
    <updated>2018-04-04T07:12:10.673Z</updated>
    
    <content type="html"><![CDATA[<p>这个是受路人甲 之前发的一个插件的影响</p><p>我下载下来了 发现 竟然用不了。。。</p><p>而且只支持问题页看图</p><p>所以就修改了下。。。</p><p>而且开源放到了github上，主要是希望大家能一起维护他</p><p>毕竟靠一个人来做的话，是比较难的。。。</p><p>而且我比较懒。。。</p><p>我是个js菜鸟，代码有啥不忍直视的地方。。。</p><p>请随便喷。。。</p><h2 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h2><ol><li><p>把项目下载到本地</p></li><li><p>在chrome浏览器的地址栏输入 <code>chrome://extensions/</code></p></li><li>点击加载已解压的扩展程序</li><li>找到刚才下载的目录</li><li>如图所示，你就可以愉快的看图了<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fp3edo75urj20mb05g3yr.jpg" alt=""></li></ol><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p><code>Ctrl + Alt + D</code>开始运行插件<br><code>Ctrl + Alt + F</code>开始看图模式<br>方向键盘左键向左查看，右键向右查看<br>Esc退出看图模式</p><p>目前支持知乎上所有的页面的看图(如有不支持的，欢迎提issue)</p><p>项目地址在<a href="https://github.com/jin10086/zhihukantu" rel="external nofollow noopener noreferrer" target="_blank">知乎看图</a></p><h2 id="功能演示"><a href="#功能演示" class="headerlink" title="功能演示"></a>功能演示</h2><p>就是打开 你想看图的页面，然后输入Ctrl + Alt + D<br>再输入Ctrl + Alt + F 就可以愉快的看图了…</p><p><img src="http://wx1.sinaimg.cn/mw690/cfc08357gy1fp45ejqpryg20dc07i4qs.gif" alt="9gNGRJ.gif"><br><img src="http://wx2.sinaimg.cn/mw690/cfc08357gy1fp45f3pgl1g20dc07i7wj.gif" alt="9gN8G4.gif"></p><h2 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a>Todo</h2><ul><li>自动加载下一页图片</li><li>自动播放图片</li><li>看图支持评论与弹幕展示</li><li>双击图片直接点赞</li><li>右键直接到回答者页面看图</li></ul><h2 id="来贡献代码把"><a href="#来贡献代码把" class="headerlink" title="来贡献代码把"></a>来贡献代码把</h2><p>欢迎来提bug,来贡献代码.</p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      这个是受路人甲 之前发的一个插件的影响

我下载下来了 发现 竟然用不了。。。

而且只支持问题页看图

所以就修改了下。。。

而且开源放到了github上，主要是希望大家能一起维护他

毕竟靠一个人来做的话，是比较难的。。。

而且我比较懒。。。

我是个js菜鸟，代码有啥不忍直视的地方。。。

请随便喷。。。

如何安装
 1. 把项目下载到本地
    
    
 2. 在chrome浏览器的地址栏输入 chrome://extensions/
    
    
 3. 点击加载已解压的扩展程序
 4. 找到刚才下载的目录
 5. 如图所示，你就可以愉快的看图了
    

如何使
    
    </summary>
    
      <category term="知乎" scheme="https://jin10086.github.io/categories/%E7%9F%A5%E4%B9%8E/"/>
    
    
      <category term="chrome插件" scheme="https://jin10086.github.io/tags/chrome%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>从爬虫角度来说下360快视频事件</title>
    <link href="https://jin10086.github.io/2018/02/21/%E4%BB%8E%E7%88%AC%E8%99%AB%E8%A7%92%E5%BA%A6%E6%9D%A5%E8%AF%B4%E4%B8%8B360%E5%BF%AB%E8%A7%86%E9%A2%91%E4%BA%8B%E4%BB%B6/"/>
    <id>https://jin10086.github.io/2018/02/21/从爬虫角度来说下360快视频事件/</id>
    <published>2018-02-21T04:58:50.000Z</published>
    <updated>2018-04-04T07:12:10.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="360快视频事件"><a href="#360快视频事件" class="headerlink" title="360快视频事件"></a>360快视频事件</h2><blockquote><p>最开始好像是东方华灯宴的视频被发现被盗用，然后众用户排查发现大量B站视频被快视频盗用，连用户和评论也大量照搬，并有很多B站用户发现使用B站的用户名、密码可以直接在快视频上登录一个账号。</p></blockquote><p>详情可以看知乎问题页 <a href="https://www.zhihu.com/question/267364872" rel="external nofollow noopener noreferrer" target="_blank">如何看待360快视频大量盗用B站视频和用户个人信息数据？</a></p><h2 id="他是怎么实现的"><a href="#他是怎么实现的" class="headerlink" title="他是怎么实现的"></a>他是怎么实现的</h2><p>有网友是这样猜测的</p><blockquote><p>A.360主动参与了针对用户群体个人信息数据库的盗窃和/或非法买卖行为；<br>B.360一直在通过各种渠道(比如某些有名的“安全杀毒软件”)收集用户的录入信息，特别是用户名和密码；<br>C.用户名和密码都是B站用户托梦告诉360的；<br>D.今天天气真好。</p></blockquote><p>以上来自<a href="https://www.zhihu.com/question/267364872/answer/322975937" rel="external nofollow noopener noreferrer" target="_blank">如何看待360快视频大量盗用B站视频和用户<br>个人信息数据？ - 苏翻译的回答 - 知乎</a></p><p>我说句难听的话，这兄弟估计没有听说过爬虫…</p><p>那假如是我，要做出这种软件，我怎么做呢</p><h3 id="视频信息以及个人用户信息的抓取"><a href="#视频信息以及个人用户信息的抓取" class="headerlink" title="视频信息以及个人用户信息的抓取"></a>视频信息以及个人用户信息的抓取</h3><p>这个对360团队来说应该很简单，毕竟自己做了搜索引擎，很多公司都希望他来抓。</p><p>所以抓取视频信息，评论信息，做一个个人页，换上一样的id 以及头像都是很简单的。</p><p>因为这些信息 在B站上完全可以获取到</p><h3 id="为啥能用B站的账号能直接登陆360快视频？"><a href="#为啥能用B站的账号能直接登陆360快视频？" class="headerlink" title="为啥能用B站的账号能直接登陆360快视频？"></a>为啥能用B站的账号能直接登陆360快视频？</h3><p>很多人猜测是被脱裤了<br>也不是没有这个可能，不过这种方法不太好</p><ol><li>实时性不够高</li><li>有法律风险</li></ol><p>最简单的方法也是爬虫</p><p>具体如何实现的呢？<br>我画了一个小图</p><p>正常流程<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fonzrwcaimj20dc08174f.jpg" alt=""></p><p>360快视频的流程</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fonzuj8l8tj20iw0bzwf2.jpg" alt=""></p><p>简单的讲就是 当你在360快视频输入账号密码的时候，<strong>我把你的账号密码拿去B站模拟登陆，登陆成功则获取你在B站的个人页，然后让你跳转到360快视频对应的个人页</strong>，<br>如果登陆不成功，则把B站返回的内容（如用户名或者密码错误）返回给用户</p><h3 id="所以我没有拿到你的账号密码也可以做到和你的网站自动关联"><a href="#所以我没有拿到你的账号密码也可以做到和你的网站自动关联" class="headerlink" title="所以我没有拿到你的账号密码也可以做到和你的网站自动关联."></a>所以我没有拿到你的账号密码也可以做到和你的网站自动关联.</h3><h3 id="这个实现起来难么？"><a href="#这个实现起来难么？" class="headerlink" title="这个实现起来难么？"></a>这个实现起来难么？</h3><p>很简单把…</p><h3 id="你咋知道的？"><a href="#你咋知道的？" class="headerlink" title="你咋知道的？"></a>你咋知道的？</h3><p>我以前做过这种…</p><h3 id="还有别的例子么？"><a href="#还有别的例子么？" class="headerlink" title="还有别的例子么？"></a>还有别的例子么？</h3><ul><li>支付宝里面的公积金账号查询</li><li>一些第三方的学信网信息查询（还让你自己输入手机验证码呢！！！）</li><li>等等等…这个很普遍…</li></ul><h2 id="最后吐槽时间"><a href="#最后吐槽时间" class="headerlink" title="最后吐槽时间"></a>最后吐槽时间</h2><blockquote><p>你只要安装了360安全卫士，不出一个星期，你的电脑上就会莫名其妙出现一系列360的产品，这就是俗称的360全家桶。来源于<a href="http://zhuanlan.zhihu.com/p/33887437" rel="external nofollow noopener noreferrer" target="_blank">快视频：剽窃了B站的数据库？360的常规操作了。 - 温柔的文章 - 知乎</a></p></blockquote><p>我觉得360这件事做的不对，但是也不能随便诬赖人家啊。。。<br>我电脑包括公司里面的，<br>一直装了360<br>都用了接近快5年了，也没有被自动装上360全家桶啊。。。<br>难道是因为我装的是假的360 么？</p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      360快视频事件
最开始好像是东方华灯宴的视频被发现被盗用，然后众用户排查发现大量B站视频被快视频盗用，连用户和评论也大量照搬，并有很多B站用户发现使用B站的用户名、密码可以直接在快视频上登录一个账号。

详情可以看知乎问题页 如何看待360快视频大量盗用B站视频和用户个人信息数据？

他是怎么实现的
有网友是这样猜测的

A.360主动参与了针对用户群体个人信息数据库的盗窃和/或非法买卖行为；
B.360一直在通过各种渠道(比如某些有名的“安全杀毒软件”)收集用户的录入信息，特别是用户名和密码；
C.用户名和密码都是B站用户托梦告诉360的；
D.今天天气真好。

以上来自如何看待360快视
    
    </summary>
    
      <category term="爬虫" scheme="https://jin10086.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫的应用" scheme="https://jin10086.github.io/tags/%E7%88%AC%E8%99%AB%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>佛系编程[如何创建一个安全可靠的应用程序]</title>
    <link href="https://jin10086.github.io/2018/02/08/%E4%BD%9B%E6%80%A7%E7%BC%96%E7%A8%8B/"/>
    <id>https://jin10086.github.io/2018/02/08/佛性编程/</id>
    <published>2018-02-08T08:58:56.000Z</published>
    <updated>2018-04-04T07:12:10.671Z</updated>
    
    <content type="html"><![CDATA[<p>推荐最近在GitHub上很火的一个项目，按照介绍，你也可以创建一个安全可靠的应用程序</p><p><a href="https://github.com/kelseyhightower/nocode" rel="external nofollow noopener noreferrer" target="_blank">nocode</a><a href="https://github.com/kelseyhightower/nocode" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/kelseyhightower/nocode</a></p><p>以下是项目介绍</p><h1 id="No-Code"><a href="#No-Code" class="headerlink" title="No Code"></a>No Code</h1><p>No code is the best way to write secure and reliable applications. Write nothing; deploy nowhere.</p><h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><p>Start by not writing any code.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>This is just an example application, but imagine it doing anything you want. Adding new features is easy too:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>The possibilities are endless.</p><h3 id="Building-the-Application"><a href="#Building-the-Application" class="headerlink" title="Building the Application"></a>Building the Application</h3><p>Now that you have not done anything it’s time to build your application:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Yep. That’s it. You should see the following output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Deploying"><a href="#Deploying" class="headerlink" title="Deploying"></a>Deploying</h3><p>While you still have not done anything it’s time to deploy your application. By running the following command you can deploy your application absolutely nowhere.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>It’s that simple. And when it comes time to scale the application, all you have to do is:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>I know right?</p><h2 id="Contributing"><a href="#Contributing" class="headerlink" title="Contributing"></a>Contributing</h2><p>You don’t.</p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      推荐最近在GitHub上很火的一个项目，按照介绍，你也可以创建一个安全可靠的应用程序

nocodehttps://github.com/kelseyhightower/nocode

以下是项目介绍

No Code
No code is the best way to write secure and reliable applications. Write nothing; deploy nowhere.

Getting Started
Start by not writing any code.

1
2






This is just an example applicati
    
    </summary>
    
      <category term="编程随想" scheme="https://jin10086.github.io/categories/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="好玩的项目" scheme="https://jin10086.github.io/tags/%E5%A5%BD%E7%8E%A9%E7%9A%84%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>websocket与爬虫</title>
    <link href="https://jin10086.github.io/2018/02/04/websocket%E4%B8%8E%E7%88%AC%E8%99%AB/"/>
    <id>https://jin10086.github.io/2018/02/04/websocket与爬虫/</id>
    <published>2018-02-04T13:24:16.000Z</published>
    <updated>2018-04-04T07:12:10.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>写爬虫的目的应该就是为了拿到数据，或者说模拟某种操作<br>如果他使用的是http(s) 协议来传输数据的，那么我们就模拟http协议来发送数据<br>如果它使用的是websocket协议来传输数据的，<br>那么我们理所当然的就模拟websocket来发送数据~</p><p>首先，我们需要了解什么是websocket</p><h2 id="websocket的介绍"><a href="#websocket的介绍" class="headerlink" title="websocket的介绍"></a>websocket的介绍</h2><blockquote><p>WebSocket是一种在单个TCP连接上进行全双工通讯的协议。WebSocket通信协议于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准。</p></blockquote><blockquote><p>WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p></blockquote><p>上面是维基百科的介绍.<br>简单的将，websocket 和http一样，都是一种网络传输协议</p><h3 id="他比http协议好的地址有哪些呢？"><a href="#他比http协议好的地址有哪些呢？" class="headerlink" title="他比http协议好的地址有哪些呢？"></a>他比http协议好的地址有哪些呢？</h3><ul><li>较少的控制开销。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10字节（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的掩码。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。</li><li>更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。</li><li>保持连接状态。于HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。</li><li>更好的二进制支持。Websocket定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容。</li><li>可以支持扩展。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等。</li><li>更好的压缩效果。相对于HTTP压缩，Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率</li></ul><h3 id="websocket的应用场景"><a href="#websocket的应用场景" class="headerlink" title="websocket的应用场景"></a>websocket的应用场景</h3><ul><li>直播平台的弹幕</li><li>实时聊天</li><li>等等</li></ul><h2 id="websocket-协议"><a href="#websocket-协议" class="headerlink" title="websocket 协议"></a>websocket 协议</h2><p>WebSocket 是独立的、创建在 TCP 上的协议。</p><p>Websocket 通过 HTTP/1.1 协议的101状态码进行握手。</p><p>为了创建Websocket连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为“握手”</p><p>那么websocket协议是如何握手的呢？</p><h3 id="websocket握手"><a href="#websocket握手" class="headerlink" title="websocket握手"></a>websocket握手</h3><p>下面是websocket一次握手的过程<br><strong>客户端请求</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Host: example.com</span><br><span class="line">Origin: http://example.com</span><br><span class="line">Sec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure></p><p><strong>服务器响应</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=</span><br><span class="line">Sec-WebSocket-Location: ws://example.com/</span><br></pre></td></tr></table></figure></p><p><strong>和http字段不一样的地方</strong></p><ul><li>Connection必须设置Upgrade，表示客户端希望连接升级。</li><li>Upgrade字段必须设置Websocket，表示希望升级到Websocket协议。</li><li>Sec-WebSocket-Key是随机的字符串，服务器端会用这些数据来构造出一个SHA-1的信息摘要。把“Sec-WebSocket-Key”加上一个特殊字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，然后计算SHA-1摘要，之后进行BASE-64编码，将结果做为“Sec-WebSocket-Accept”头的值，返回给客户端。如此操作，可以尽量避免普通HTTP请求被误认为Websocket协议。</li><li>Sec-WebSocket-Version 表示支持的Websocket版本。RFC6455要求使用的版本是13，之前草案的版本均应当弃用。</li><li>Origin字段是可选的，通常用来表示在浏览器中发起此Websocket连接所在的页面，类似于Referer。但是，与Referer不同的是，Origin只包含了协议和主机名称。</li><li>其他一些定义在HTTP协议中的字段，如Cookie等，也可以在Websocket中使用。</li></ul><p>可以看到只是在http协议上增加了几个硬性规定，http协议的user-agent,cookie都可以在websocket握手过程中使用</p><p><strong>抓包时候的注意事项:因为websocket只有一次握手，握手成功后就可以双方发送消息了，假如你打开网页后没有找到你要抓的数据，那么你就需要重新刷新网页，让他重新握手一次</strong></p><h2 id="websocket的事件"><a href="#websocket的事件" class="headerlink" title="websocket的事件"></a>websocket的事件</h2><h3 id="on-open"><a href="#on-open" class="headerlink" title="on_open"></a>on_open</h3><p>表示刚刚连接的时候</p><h3 id="onmessage"><a href="#onmessage" class="headerlink" title="onmessage"></a>onmessage</h3><p>表示收到消息怎么做</p><h3 id="send"><a href="#send" class="headerlink" title="send"></a>send</h3><p>表示给服务器发送消息</p><h3 id="on-close"><a href="#on-close" class="headerlink" title="on_close"></a>on_close</h3><p>表示关闭连接</p><p>那么知道了这些对我们有什么好处么?<br>找js的时候会很好找，这几个关键词基本上都是固定的<br>你可以直接全局搜搜,然后很容易能找到发送的js代码</p><p>模拟发送的时候也是一样的.</p><h2 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h2><p>前面介绍了一堆websocket协议相关的东西，估计很多人已经晕了.<br>没关系，先看实例，有问题再回到上面看</p><h3 id="抓包可以使用fiddle，chrome也是可以的"><a href="#抓包可以使用fiddle，chrome也是可以的" class="headerlink" title="抓包可以使用fiddle，chrome也是可以的"></a>抓包可以使用fiddle，chrome也是可以的</h3><p>我们先使用chrome</p><p>本次要抓的网站的<a href="http://www.10brandchina.com/vote/startin.php?id=41867" rel="external nofollow noopener noreferrer" target="_blank">一个投票网站</a><br>大家可以先随便投一个票，抓抓包看看<br>会发现怎么没有找到他是如何提交数据的…</p><p>选择ws,然后刷新下网页，再点击下投票，会发现有一个请求<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo4rs5d7hjj20zf0bugmx.jpg" alt=""></p><p>可以看到是在握手阶段,请求头里面的参数和我们上面讲的是一样的.</p><p>请求地址是<code>ws://v5.10brandchina.com:8008/</code><br>这边顺带说一下，有时候这边会看到 <code>wss://v5.10brandchina.com:8008/</code><br>那么这两个有啥区别的，简单的讲就是http与https协议的区别一样…<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo4rykh56tj20ah027mx2.jpg" alt=""></p><p>看一下交互的内容（点击Frames）<br>可以看到已经有四条消息了，但是消息内容是二进制的，chrome这边无法预览…<br>那么我们使用fiddle试一下</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo4s0okwq0j20d505fmx7.jpg" alt=""></p><h3 id="抓包与分析"><a href="#抓包与分析" class="headerlink" title="抓包与分析"></a>抓包与分析</h3><p>打开fiddle，<strong>刷新一下网页</strong><br>不刷新的话是看不到的，然后随便投一下票.</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo4s4eceovj20ki08dmy3.jpg" alt=""></p><p>怎么找到请求呢，很简单，看状态码为101的就行，然后双击这一行</p><p>然后这边还是看到四条消息，我们点击第一条，然后用<code>TextView</code>展示，可以看到消息是这些<br>为啥用<code>TextView</code>呢？其实是一个一个的试过来的，假如你发现都试过了，还是乱码，那应该是他使用了其他的压缩或者加密方法，需要查看js看看他是如何加密的</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo4si2qs3uj20d1074t8w.jpg" alt=""></p><p>这个网站的数据是没有加密过的.<br>带向上的箭头的是我们向服务器发送的，向下的箭头是服务器返回的(下面的数据，前面带黑点？,是我们发送的)</p><ul><li><code>{&quot;action&quot;:&quot;auth&quot;,&quot;val&quot;:5}</code></li></ul><p><code>{&quot;action&quot;:&quot;auth&quot;,&quot;msg&quot;:&quot;eval(\&quot;\\115\\141\\164\\150\\56\\163\\151\\156\\50\\61\\65\\61\\67\\67\\66\\62\\63\\61\\63\\51\&quot;)&quot;}</code></p><ul><li><code>{&quot;action&quot;:&quot;auth&quot;,&quot;val&quot;:-0.3241458910493796}</code></li></ul><p><code>{&quot;action&quot;:&quot;wait&quot;,&quot;msg&quot;:95420}</code></p><ul><li><code>{&quot;action&quot;:&quot;vote&quot;,&quot;val&quot;:&quot;{\&quot;itemid\&quot;:126067,\&quot;catid\&quot;:41867,\&quot;captcha\&quot;:\&quot;%u7EC7%u65E7%u5F88%u9C7C\&quot;,\&quot;auth\&quot;:5,\&quot;rnd\&quot;:\&quot;4186712606754595\&quot;}&quot;}</code></li></ul><p><code>{&quot;action&quot;:&quot;vote&quot;,&quot;msg&quot;:&quot;ok,231812,2018-02-04 22:32:55&quot;}</code></p><p>可以看出来<br>首先我们发送<code>{&quot;action&quot;:&quot;auth&quot;,&quot;val&quot;:5}</code><br>然后服务器返回一串信息给我们,<br>然后我们根据服务器返回的算出一个值,也就是<br><code>{&quot;action&quot;:&quot;auth&quot;,&quot;val&quot;:-0.3241458910493796}</code><br>再发送给服务器.<br>服务器返回<code>{&quot;action&quot;:&quot;wait&quot;,&quot;msg&quot;:95420}</code>,表示验证通过<br>然后我们投票,发送了投票的一些信息给服务<br>服务器告诉我们投票成功.</p><p>以上就是整个通讯过程.</p><p>那如果我们要模拟发送的话，需要知道哪些信息呢</p><ol><li><code>{&quot;action&quot;:&quot;auth&quot;,&quot;val&quot;:5}</code>里面的<code>val:5</code>,这个5是固定的么？如果不是，是如何生成的</li><li>服务器返回的是什么，如何解析</li><li>如何根据服务器返回的生成一个新的val</li><li>发送投票信息里面<code>{&quot;action&quot;:&quot;vote&quot;,&quot;val&quot;:&quot;{\&quot;itemid\&quot;:126067,\&quot;catid\&quot;:41867,\&quot;captcha\&quot;:\&quot;%u7EC7%u65E7%u5F88%u9C7C\&quot;,\&quot;auth\&quot;:5,\&quot;rnd\&quot;:\&quot;4186712606754595\&quot;}&quot;}</code><br>itemid,catid,capthc,auth,rnd如何生成</li></ol><h2 id="找参数"><a href="#找参数" class="headerlink" title="找参数"></a>找参数</h2><p>还是使用chrome，直接用<code>ctrl + shift +f</code>，然后输入websocket（或者on_open,on_message，等等上面提到的事件去搜索）</p><p>运气很好，输入<code>websocket</code>直接就搜到了js,还是没有混淆的<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo4t04u89ej20i30410t0.jpg" alt=""></p><p>首先发现 websocket 地址是根据catId变的，如果catId能被2整除则地址为xxx，否则为xxx<br>那么catId是什么呢，调试发现就是url中的id，我们当前url为<code>http://www.10brandchina.com/vote/startin.php?id=41867</code>则 catId为<code>41867</code></p><p>然后onmessage也看到了，大概意思是收到信息后，用json解析，如果action是auth的话，则调用sendData这个方法，如果action是vote的话，则使用vote_resule方法.</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo4t2w87vsj20gp0fm0to.jpg" alt=""></p><p>在看到onopen方法，是调用sendData,并发送<code>(&#39;auth&#39;,authType)</code>,在这边是不是联想到前面，我们第一次发送的数据？<code>{&quot;action&quot;:&quot;auth&quot;,&quot;val&quot;:5}</code>,是不是感觉一模一样</p><p>close方法就不说了,反正我们也用不上<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo4tg5g7kyj20dl01ba9w.jpg" alt=""></p><p>再看看sendData这个方法,<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo4tj2ks1vj20hw07awet.jpg" alt=""><br>用python实现的话是这样<img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo4tnwvhgjj20cd02qt8n.jpg" alt=""></p><p>再看vote_result方法，大概作用是判断投票结果<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo4tpk059lj20nc0e0myk.jpg" alt=""></p><p>所有的方法我们都找到了，那么我们再和之前要找的参数走一遍.</p><ol><li><p><code>{&quot;action&quot;:&quot;auth&quot;,&quot;val&quot;:5}</code>里面的<code>val:5</code>,这个5是固定的么？如果不是，是如何生成的</p><p><strong>这个5也就是onopen里面的authType，至于authType是不是固定的，搜索一下就知道了.</strong></p></li><li><p>服务器返回的是什么，如何解析</p></li><li><p>如何根据服务器返回的生成一个新的val</p><p><strong>可以通过onmessage方法知道他返回的json数据，json解析一下就行，</strong><br><strong>里面的val是通过执行 <code>eval(val)</code>得到的</strong><br><strong>所以你也可以直接执行这个.或者用python实现</strong><br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo4twpructj20c109igm0.jpg" alt=""></p></li><li><p>发送投票信息里面<code>{&quot;action&quot;:&quot;vote&quot;,&quot;val&quot;:&quot;{\&quot;itemid\&quot;:126067,\&quot;catid\&quot;:41867,\&quot;captcha\&quot;:\&quot;%u7EC7%u65E7%u5F88%u9C7C\&quot;,\&quot;auth\&quot;:5,\&quot;rnd\&quot;:\&quot;4186712606754595\&quot;}&quot;}</code><br>itemid,catid,capthc,auth,rnd如何生成</p></li></ol><p><strong>itemid 就是你投票的公司的id，catid之前讲过，captcha就是验证码,</strong><br><strong>auth和上面的authtype一样</strong><br><strong>rnd是通过搜索js发现了.</strong><br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo4u0llrazj20uo03t0sz.jpg" alt=""></p><p>再看看验证码是如何生成的呢<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo4u2gg6f5j20o507x0t9.jpg" alt=""></p><p>检查验证码是否正确<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo4u3248gpj20um09adgu.jpg" alt=""></p><p>我们已经拿到所有需要的东西了，只要用程序模拟发送就行了.</p><h2 id="模拟发送"><a href="#模拟发送" class="headerlink" title="模拟发送"></a>模拟发送</h2><p>使用的包是<a href="https://github.com/websocket-client/websocket-client/" rel="external nofollow noopener noreferrer" target="_blank">websocket</a></p><p>官方demo<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> websocket</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> thread</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">import</span> _thread <span class="keyword">as</span> thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span><span class="params">(ws, message)</span>:</span></span><br><span class="line">    print(message)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_error</span><span class="params">(ws, error)</span>:</span></span><br><span class="line">    print(error)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_close</span><span class="params">(ws)</span>:</span></span><br><span class="line">    print(<span class="string">"### closed ###"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_open</span><span class="params">(ws)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(*args)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            ws.send(<span class="string">"Hello %d"</span> % i)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        ws.close()</span><br><span class="line">        print(<span class="string">"thread terminating..."</span>)</span><br><span class="line">    thread.start_new_thread(run, ())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    websocket.enableTrace(<span class="keyword">True</span>)</span><br><span class="line">    ws = websocket.WebSocketApp(<span class="string">"ws://echo.websocket.org/"</span>,</span><br><span class="line">                              on_message = on_message,</span><br><span class="line">                              on_error = on_error,</span><br><span class="line">                              on_close = on_close)</span><br><span class="line">    ws.on_open = on_open</span><br><span class="line">    ws.run_forever()</span><br></pre></td></tr></table></figure></p><p>可以看到使用还是很简单的，也是<code>onopen,onmessage,send</code></p><p>所以我们只要用我们上面得到的信息就行模拟发送就可以了</p><p>因为是投票网站，所以不提供代码…有啥问题，请留言~</p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      背景
写爬虫的目的应该就是为了拿到数据，或者说模拟某种操作
如果他使用的是http(s) 协议来传输数据的，那么我们就模拟http协议来发送数据
如果它使用的是websocket协议来传输数据的，
那么我们理所当然的就模拟websocket来发送数据~

首先，我们需要了解什么是websocket

websocket的介绍
WebSocket是一种在单个TCP连接上进行全双工通讯的协议。WebSocket通信协议于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准。

WebSocket使得客户端和服务器之间的数据交换变得更
    
    </summary>
    
      <category term="爬虫" scheme="https://jin10086.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="websocket" scheme="https://jin10086.github.io/tags/websocket/"/>
    
      <category term="websocket抓包" scheme="https://jin10086.github.io/tags/websocket%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>github如何创建ssh-key</title>
    <link href="https://jin10086.github.io/2018/02/03/github%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAssh-key/"/>
    <id>https://jin10086.github.io/2018/02/03/github如何创建ssh-key/</id>
    <published>2018-02-03T11:07:56.000Z</published>
    <updated>2018-04-04T07:12:10.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在写几个私有项目,每次提交都需要输入账号密码，很烦…</p><p>搜索发现如果使用ssh协议来提交的话，只要生成ssh key，就不需要输入账号密码了</p><h2 id="本地ssh-key的创建"><a href="#本地ssh-key的创建" class="headerlink" title="本地ssh-key的创建"></a>本地ssh-key的创建</h2><p>默认已经装好了git,如果没有安装的话，请百度如何安装</p><p>在命令行中输入下面命令<br><code>ssh-keygen -t rsa -C &quot;你的邮箱地址&quot;</code></p><p>如果提示找不到ssh-keygen 这个命令的话,请检查是否有安装git 以及是否要ssh-keygen加入环境变量<br>然后直接回车三连（三次回车）<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3h4q7e9xj20gz09wwf1.jpg" alt=""></p><p>然后 li* mac 等系统的同学 直接输入<br><code>cat ~/.ssh/id_rsa.pub</code> 然后直接复制里面的所有的内容</p><p>windows的同学,打开当前计算机名（如我当前计算机名是 <code>kimga</code><br><code>C:\Users\kimga\.ssh</code>下面的<code>id_rsa.pub</code>,然后复制里面的所有内容<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3h7ooj2gj20ay044jre.jpg" alt=""></p><h2 id="github-设置"><a href="#github-设置" class="headerlink" title="github 设置"></a>github 设置</h2><ol><li>打开github<a href="https://github.com/settings/ssh/new" rel="external nofollow noopener noreferrer" target="_blank">设置ssh-key的地址</a></li><li>在title里面输入你这个key用在哪的,(可以随便写)</li><li>在key里面粘贴进去上面复制的</li><li><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3haocqmmj20lt0c83yu.jpg" alt=""></li><li>点击add ssh key，然后输入GitHub密码就好了</li></ol><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在命令行输入<br><code>ssh -T git@github.com</code><br>会有一个警告,直接输入<code>yes</code><br>然后会看到 <code>Hi xxx! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code><br>则成功了<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3hfokg3kj20k103hmxf.jpg" alt=""></p><h2 id="在项目中使用ssh协议"><a href="#在项目中使用ssh协议" class="headerlink" title="在项目中使用ssh协议"></a>在项目中使用ssh协议</h2><p>有两种情况</p><ol><li><p>你项目还没有clone 下来，则你clone的时候直接使用ssh协议<br>如下图，点击Use SSH,然后复制地址<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3hj3l773j20b205y3yt.jpg" alt=""><br>正常clone，如<code>git clone git@github.com:jin10086/pachong.git</code></p></li><li><p>你项目已经clone下来了，但是用的是https协议，则需要更改下remote url<br>怎么做的，看下面</p><ol><li>输入<code>git remote -v</code> 查看当前的url，可以发现我使用的https协议</li><li><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3hm0gw5kj20cl020748.jpg" alt=""></li><li>输入<code>git remote set-url origin git@github.com:jin10086/pachong.git</code>,后面的git协议的地址获取方法和 方法1一样的.</li><li>输入<code>git remote -v</code>看看是否有修改成功</li><li><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3hnu7ygaj20k002owel.jpg" alt=""></li></ol></li></ol><p>最后，愉快的使用github把，再也不用每次都输入密码了~</p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      背景
最近在写几个私有项目,每次提交都需要输入账号密码，很烦…

搜索发现如果使用ssh协议来提交的话，只要生成ssh key，就不需要输入账号密码了

本地ssh-key的创建
默认已经装好了git,如果没有安装的话，请百度如何安装

在命令行中输入下面命令
ssh-keygen -t rsa -C &quot;你的邮箱地址&quot;

如果提示找不到ssh-keygen 这个命令的话,请检查是否有安装git 以及是否要ssh-keygen加入环境变量
然后直接回车三连（三次回车）


然后 li* mac 等系统的同学 直接输入
cat ~/.ssh/id_rsa.pub 然后直接复制里面的所有的内容

w
    
    </summary>
    
      <category term="github" scheme="https://jin10086.github.io/categories/github/"/>
    
    
      <category term="sshkey" scheme="https://jin10086.github.io/tags/sshkey/"/>
    
  </entry>
  
  <entry>
    <title>傻逼的我</title>
    <link href="https://jin10086.github.io/2018/02/03/%E5%82%BB%E9%80%BC%E7%9A%84%E6%88%91/"/>
    <id>https://jin10086.github.io/2018/02/03/傻逼的我/</id>
    <published>2018-02-03T10:41:16.000Z</published>
    <updated>2018-04-04T07:12:10.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前几天部门老大突然找到我，说因为我技术比较垃圾，所以不想和我续签了。（我还在试用期内）</p><p>然后我自己想了一晚上，觉得他说的一些地方我确实不足</p><p>然后就<strong>自己填了离职申请单</strong></p><p>过两天发现，和我一起进去的二位同事也被开了（也都在试用期内）。。。</p><p>而且我之前所在的部门也辞退了5个人（一共应该18个人左右把）</p><p>发现和我一起进去的同事竟然有补偿金</p><p>然后就问了hr说，为啥不给我补偿金，hr说因为我自己垃圾，所以不给。。。</p><p>然后我就申请了劳动仲裁。。。</p><p>结果呢，我输了</p><p>原因是啥呢，因为我填了<strong>离职申请单</strong>！！！</p><p>只要填了离职申请单，仲裁老师说 打官司肯定是输的，除非你有证据证明是他们逼你填的…</p><p>写出来呢，主要是为了给像我一样的小白提个醒，</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>不管公司说你垃圾，说你技术不行，如果要你走，千万不要主动填 离职申请单，填了的话，你申请仲裁肯定是输的，打官司也是输的</p></li><li><p>找个靠谱的公司</p></li><li><p>好好提升技术</p></li></ol><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      背景
前几天部门老大突然找到我，说因为我技术比较垃圾，所以不想和我续签了。（我还在试用期内）

然后我自己想了一晚上，觉得他说的一些地方我确实不足

然后就自己填了离职申请单

过两天发现，和我一起进去的二位同事也被开了（也都在试用期内）。。。

而且我之前所在的部门也辞退了5个人（一共应该18个人左右把）

发现和我一起进去的同事竟然有补偿金

然后就问了hr说，为啥不给我补偿金，hr说因为我自己垃圾，所以不给。。。

然后我就申请了劳动仲裁。。。

结果呢，我输了

原因是啥呢，因为我填了离职申请单！！！

只要填了离职申请单，仲裁老师说 打官司肯定是输的，除非你有证据证明是他们逼你填的…
    
    </summary>
    
      <category term="职场" scheme="https://jin10086.github.io/categories/%E8%81%8C%E5%9C%BA/"/>
    
    
      <category term="职场的坑" scheme="https://jin10086.github.io/tags/%E8%81%8C%E5%9C%BA%E7%9A%84%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>python版冲顶大会来了，该我们pythoner上场了</title>
    <link href="https://jin10086.github.io/2018/02/03/python%E7%89%88%E5%86%B2%E9%A1%B6%E5%A4%A7%E4%BC%9A%E6%9D%A5%E4%BA%86%EF%BC%8C%E8%AF%A5%E6%88%91%E4%BB%ACpythoner%E4%B8%8A%E5%9C%BA%E4%BA%86/"/>
    <id>https://jin10086.github.io/2018/02/03/python版冲顶大会来了，该我们pythoner上场了/</id>
    <published>2018-02-03T10:37:39.000Z</published>
    <updated>2018-04-04T07:12:10.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近，异常火爆的</p><p>「冲顶大会」or「百万英雄」or「知识超人」</p><p>每天都在我的朋友圈刷屏</p><p>不少人都陷入废寝忘食答题闯关的状态中</p><p>我也终于在越挫越勇不懈努力下</p><p>一次都没冲顶成功<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fzh1tvrj201s01sq2w.jpg" alt=""><br>不过，作为一个</p><p>追热点蹭关注精通各种互联网小道消息的</p><p>运营</p><p>聊人生哲学历史艺术算什么好汉！</p><p>不服你来我的主场</p><p>「python版冲顶大会」比一比</p><p>一共12道涵盖python热点及必备知识的问题 </p><p><img src="https://pic4.zhimg.com/v2-c14dbe46c110c10fe1313609bf209128_b.gif" alt=""></p><p>是<strong>pythoner</strong>就来冲顶！</p><p><a href="http://togetthere.cn/chongdingdahui.html" rel="external nofollow noopener noreferrer" target="_blank">冲顶大会地址在这</a><br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3g17mlxxj201s01sq2x.jpg" alt=""><br>最后P个S：主播是花大价钱请来的，异常貌美，不容错过！</p><p>创意抄的三节课的</p><p>代码也是抄的</p><p>就改了下题目</p><p>谢谢三节课爸爸</p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      背景
最近，异常火爆的

「冲顶大会」or「百万英雄」or「知识超人」

每天都在我的朋友圈刷屏

不少人都陷入废寝忘食答题闯关的状态中

我也终于在越挫越勇不懈努力下

一次都没冲顶成功

不过，作为一个

追热点蹭关注精通各种互联网小道消息的

运营

聊人生哲学历史艺术算什么好汉！

不服你来我的主场

「python版冲顶大会」比一比

一共12道涵盖python热点及必备知识的问题 



是pythoner就来冲顶！

冲顶大会地址在这

最后P个S：主播是花大价钱请来的，异常貌美，不容错过！

创意抄的三节课的

代码也是抄的

就改了下题目

谢谢三节课爸爸
    
    </summary>
    
      <category term="python" scheme="https://jin10086.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://jin10086.github.io/tags/python/"/>
    
      <category term="冲顶大会" scheme="https://jin10086.github.io/tags/%E5%86%B2%E9%A1%B6%E5%A4%A7%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title>再也不用担心网页编码的坑了！</title>
    <link href="https://jin10086.github.io/2018/02/03/%E5%86%8D%E4%B9%9F%E4%B8%8D%E7%94%A8%E6%8B%85%E5%BF%83%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A0%81%E7%9A%84%E5%9D%91%E4%BA%86%EF%BC%81/"/>
    <id>https://jin10086.github.io/2018/02/03/再也不用担心网页编码的坑了！/</id>
    <published>2018-02-03T10:32:31.000Z</published>
    <updated>2018-04-04T07:12:10.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>大家爬取网页的时候，应该都遇到过这种情况 </p><p>当我打印网页源代码的时候</p><p>发现 全部是乱码的</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fukg0paj20qz09j13g.jpg" alt=""><br>那这个时候应该怎么办呢？</p><h2 id="requests是如何判断编码"><a href="#requests是如何判断编码" class="headerlink" title="requests是如何判断编码"></a>requests是如何判断编码</h2><p>首先，response.content返回的内容 是二进制内容</p><p>response.text 则是根据设置的encoding来解码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Try charset from content-type  </span></span><br><span class="line">content = <span class="keyword">None</span>  </span><br><span class="line">encoding = self.encoding  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> self.content:  </span><br><span class="line">  <span class="keyword">return</span> str(<span class="string">''</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Fallback to auto-detected encoding.  </span></span><br><span class="line"><span class="keyword">if</span> self.encoding <span class="keyword">is</span> <span class="keyword">None</span>:  </span><br><span class="line">    encoding = self.apparent_encoding  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Decode unicode from given encoding.  </span></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    content = str(self.content, encoding, errors=<span class="string">'replace'</span>)  </span><br><span class="line"><span class="keyword">except</span> (LookupError, TypeError):</span><br></pre></td></tr></table></figure><p>我们可以看到 ，当encoding为None的时候，  </p><p>编码是通过chardet.detect来获取的,<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apparent_encoding</span><span class="params">(self)</span>:</span>  </span><br><span class="line"><span class="string">"""The apparent encoding, provided by the chardet library."""</span>  </span><br><span class="line">    <span class="keyword">return</span> chardet.detect(self.content)[<span class="string">'encoding'</span>]</span><br></pre></td></tr></table></figure></p><p>那么chardet.detect 又是干嘛的呢？</p><p>简单的讲，就是根据给定的字节，来返回他的编码</p><p>至于他是如何实现的，欢迎去看源代码。。。</p><p><strong>上面说到了当encoding为None的时候,requests是如何设置encoding的</strong></p><p><strong>那么encoding 默认编码是啥呢？继续查看源代码</strong></p><p>我们在adapters.py 里面找到了~<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">response.encoding = get_encoding_from_headers(response.headers)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_encoding_from_headers</span><span class="params">(headers)</span>:</span>  </span><br><span class="line"><span class="string">"""Returns encodings from given HTTP Header Dict.  </span></span><br><span class="line"><span class="string">    :param headers: dictionary to extract encoding from.  </span></span><br><span class="line"><span class="string">    :rtype: str  </span></span><br><span class="line"><span class="string">    """</span>  </span><br><span class="line">    content_type = headers.get(<span class="string">'content-type'</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> content_type:  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">None</span>  </span><br><span class="line">content_type, params = cgi.parse_header(content_type)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">'charset'</span> <span class="keyword">in</span> params:  </span><br><span class="line">  <span class="keyword">return</span> params[<span class="string">'charset'</span>].strip(<span class="string">"'\""</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> <span class="string">'text'</span> <span class="keyword">in</span> content_type:  </span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ISO-8859-1'</span></span><br></pre></td></tr></table></figure></p><p>简单讲就是 如何返回头里面没有content_type，则encoding为None</p><p>如果charset在参数里面的话，则使用charset设置的值（看下图，github返回的）</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fw3ge2tj20gt08yjuv.jpg" alt=""><br>如果text在参数里面的话，则使用<strong>ISO-8859-1</strong></p><p>然后你打印下 你乱码网页的encoding，发现，还真是<strong>ISO-8859-1</strong></p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fwbgdztj20k802kgmd.jpg" alt=""></p><p>你会很奇怪，为啥当content-type为text/html的时候，编码为iso-8859-1呢？</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fwjpdpzj20d605lwfx.jpg" alt=""><br>现在常见的编码不是utf8么，requests怎么这么傻*呢…</p><p>然后发现是rfc2016的规定。。。</p><p>rfc2016的链接在 <a href="https://www.ietf.org/rfc/rfc2616.txt" rel="external nofollow noopener noreferrer" target="_blank">https://www.ietf.org/rfc/rfc2616.txt</a></p><p>感兴趣的同学可以自行查阅…</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fws9qdoj20fm0don3j.jpg" alt=""></p><h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h2><p><strong>当返回头没有content_type 的时候，encoding使用chardet.detect 猜测出来的编码（一般都是很准的）</strong>  </p><p><strong>当返回头里面有content_type 的时候，如果有charset=xxx，则encoding的编码为chatset的值。如果只是text/html,则编码为ISO-8859-1</strong></p><p>那么当你发现response.text返回乱码的时候，怎么办呢。。。</p><p>只要先设置编码为None…</p><p>再打印.text就可以了..<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response.encoding = <span class="keyword">None</span>  </span><br><span class="line">response.text</span><br></pre></td></tr></table></figure></p><p>本来呢，本篇文章到此结束了。。。但是呢。。。</p><h2 id="科普个小知识"><a href="#科普个小知识" class="headerlink" title="科普个小知识"></a>科普个小知识</h2><p>有几种方法可以知道网页的编码呢？</p><ol><li>我们上面讲过的 response.headers中的content_type </li><li>通过chardet.detect猜测出来（上面讲过的） </li><li>网页源代码中的 meta（且有charset的值）如下面的，则表示网页编码为gb2312（不过呢，有时候并不是很准，这个是前端瞎xx写的，这时候就可以用chardet.detect来猜测了…） </li></ol><p>方法3的代码如何写呢（如下）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_encodings_from_content</span><span class="params">(content)</span>:</span>  </span><br><span class="line"><span class="string">"""Returns encodings from given content string.  </span></span><br><span class="line"><span class="string">    :param content: bytestring to extract encodings from.  </span></span><br><span class="line"><span class="string">    """</span>  </span><br><span class="line">    warnings.warn((  </span><br><span class="line"><span class="string">'In requests 3.0, get_encodings_from_content will be removed. For '</span>  </span><br><span class="line">        <span class="string">'more information, please see the discussion on issue #2266. (This'</span>  </span><br><span class="line">        <span class="string">' warning should only appear once.)'</span>),  </span><br><span class="line">        DeprecationWarning)  </span><br><span class="line">  </span><br><span class="line">    charset_re = re.compile(<span class="string">r'&amp;lt;meta.*?charset=["\']*(.+?)["\'&amp;gt;]'</span>, flags=re.I)  </span><br><span class="line">    pragma_re = re.compile(<span class="string">r'&amp;lt;meta.*?content=["\']*;?charset=(.+?)["\'&amp;gt;]'</span>, flags=re.I)  </span><br><span class="line">    xml_re = re.compile(<span class="string">r'^&amp;lt;\?xml.*?encoding=["\']*(.+?)["\'&amp;gt;]'</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> (charset_re.findall(content) +  </span><br><span class="line">            pragma_re.findall(content) +  </span><br><span class="line">            xml_re.findall(content))</span><br></pre></td></tr></table></figure></p><p>你会看到requests3.0版本的时候，这个方法会去掉，这又是为什么呢。。。</p><p>截图自己看把，地址在<a href="https://github.com/requests/requests/issues/2266" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/requests/requests/issues/2266</a></p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fxhmk9tj20o80gy7ck.jpg" alt=""></p><p>如果还有猜测编码的方法，欢迎留言</p><p>完…</p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      背景
大家爬取网页的时候，应该都遇到过这种情况 

当我打印网页源代码的时候

发现 全部是乱码的


那这个时候应该怎么办呢？

requests是如何判断编码
首先，response.content返回的内容 是二进制内容

response.text 则是根据设置的encoding来解码

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15


# Try charset from content-type  
content = None  
encoding = self.encoding  
  
if not self.content:  
  return 
    
    </summary>
    
      <category term="爬虫" scheme="https://jin10086.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="网页编码" scheme="https://jin10086.github.io/tags/%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>爬虫小工具-copyheader</title>
    <link href="https://jin10086.github.io/2018/02/03/%E7%88%AC%E8%99%AB%E5%B0%8F%E5%B7%A5%E5%85%B7-copyheader/"/>
    <id>https://jin10086.github.io/2018/02/03/爬虫小工具-copyheader/</id>
    <published>2018-02-03T10:25:31.000Z</published>
    <updated>2018-04-04T07:12:10.673Z</updated>
    
    <content type="html"><![CDATA[<p>大家写爬虫的，肯定知道如何伪造请求头了，那么你们是如何做的呢？</p><p>首先，来看看我之前是如何做的，有多烦我就不说了…</p><p><img src="https://pic1.zhimg.com/v2-f20b1ebea73a0481283d65f632e96a3d_r.gif" alt=""></p><p>如果有小伙伴是和我一样，那么请帮忙把这篇文章分享出去~</p><p><strong>那我现在怎么是怎么做的呢？</strong></p><p><img src="https://pic2.zhimg.com/v2-81aa0e4fee50c03a19d3d6bc587c1e55_r.gif" alt=""></p><p>可以发现复制请求头很简单了，只要把请求头全部copy下来，然后用headers_raw_to_dict 转一下，就直接变成了dict了.</p><h2 id="如何安装呢"><a href="#如何安装呢" class="headerlink" title="如何安装呢"></a>如何安装呢</h2><p><code>pip install copyheaders</code></p><h2 id="如何使用呢"><a href="#如何使用呢" class="headerlink" title="如何使用呢"></a>如何使用呢</h2><p>先找到你要复制的请求头，并且复制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 引入python包</span></span><br><span class="line"><span class="keyword">from</span> copyheaders <span class="keyword">import</span> headers_raw_to_dict</span><br><span class="line">impore requests</span><br><span class="line"><span class="comment"># 把刚刚复制的请求头复制进来</span></span><br><span class="line">r_h = <span class="string">b'''</span></span><br><span class="line"><span class="string">Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span></span><br><span class="line"><span class="string">Accept-Encoding:gzip, deflate, br</span></span><br><span class="line"><span class="string">Accept-Language:zh-CN,zh;q=0.9,zh-TW;q=0.8</span></span><br><span class="line"><span class="string">Cache-Control:max-age=0</span></span><br><span class="line"><span class="string">Connection:keep-alive</span></span><br><span class="line"><span class="string">Cookie:_gauges_unique_month=1; _gauges_unique_year=1; _gauges_unique=1; _gauges_unique_hour=1; _gauges_unique_day=1</span></span><br><span class="line"><span class="string">DNT:1</span></span><br><span class="line"><span class="string">Host:httpbin.org</span></span><br><span class="line"><span class="string">Referer:https://httpbin.org/</span></span><br><span class="line"><span class="string">Upgrade-Insecure-Requests:1</span></span><br><span class="line"><span class="string">User-Agent:Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 转换成字典</span></span><br><span class="line">headers = headers_raw_to_dict(r_h)</span><br><span class="line"><span class="comment"># 然后就可以直接使用了~</span></span><br><span class="line">z = requests.get(<span class="string">'https://httpbin.org/headers'</span>,headers=headers</span><br></pre></td></tr></table></figure><p>项目地址在<a href="https://github.com/jin10086/copyheaders" rel="external nofollow noopener noreferrer" target="_blank">copyheaders</a></p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      大家写爬虫的，肯定知道如何伪造请求头了，那么你们是如何做的呢？

首先，来看看我之前是如何做的，有多烦我就不说了…



如果有小伙伴是和我一样，那么请帮忙把这篇文章分享出去~

那我现在怎么是怎么做的呢？



可以发现复制请求头很简单了，只要把请求头全部copy下来，然后用headers_raw_to_dict 转一下，就直接变成了dict了.

如何安装呢
pip install copyheaders

如何使用呢
先找到你要复制的请求头，并且复制

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21


# 引入python包

    
    </summary>
    
      <category term="爬虫" scheme="https://jin10086.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫工具" scheme="https://jin10086.github.io/tags/%E7%88%AC%E8%99%AB%E5%B7%A5%E5%85%B7/"/>
    
      <category term="copyheaders" scheme="https://jin10086.github.io/tags/copyheaders/"/>
    
  </entry>
  
  <entry>
    <title>模拟登陆知乎</title>
    <link href="https://jin10086.github.io/2018/02/03/%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86%E7%9F%A5%E4%B9%8E/"/>
    <id>https://jin10086.github.io/2018/02/03/模拟登陆知乎/</id>
    <published>2018-02-03T10:19:32.000Z</published>
    <updated>2018-04-04T07:12:10.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>为啥要写这一篇文章呢？<br>（主要是qq群内有人在模拟登陆知乎，一直不成功）然后我抓包看了下，发现知乎登陆页已经改版了，而且难度大大提高了。</p><h2 id="开始抓包"><a href="#开始抓包" class="headerlink" title="开始抓包"></a>开始抓包</h2><p>首先内，还是打开知乎首页，然后输入账号密码，登陆（记得输错密码）  </p><p>这样我们就可以看到请求头了（请求头如下）<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fgpbpfwj20s10aadp4.jpg" alt=""><br>我们发现有这几个请求头和正常的不一样（红色框中的）</p><ol><li><code>authorization</code> （感觉应该是js生成的，后面再看</li><li><code>Content-Type</code> （后面多了boundary=xxx 这种,那这种是啥意思呢,后面和请求参数一起看</li><li><code>cookie</code>：这个要注意,登陆前cookie就不为空，说明之前肯定有set-cookie的操作</li><li><code>x-udid,x-sxrftoken</code> 这两个都是验证参数,估计都在网页源代码能找到</li></ol><p>再看一下请求参数</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fgywrwfj20a50d1goo.jpg" alt=""><br>可以看到参数是以payload的形式出现的</p><p>第一次看到这种的人估计会一脸懵逼</p><p>这个要结合请求中的<code>Content-Type</code>:<code>multipart/form-data; boundary=----WebKitFormBoundary2KNsyxgtG28t93VF</code><br>来一起看</p><p><code>multipart/form-data</code> 是一种表单提交的方式，后面的boundary=xxx 是表单分割的方式，那到底啥意思呢？看一个简单的小列子你就能明白啦</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fhy0z52j20df04c40r.jpg" alt=""><br><code>------WebKitFormBoundary2KNsyxgtG28t93VF</code> 是分割不同参数的，所以可以直接不看他（这个是由上面的Content-Type后面的boundary决定的，可以随便修改）</p><p>那把分割线去掉后，上面的就相当于 <code>client_id=c3cef7c66a1843f8b3a9e6a1e3160e20</code>,</p><p><code>grant_type=password</code>.</p><p>那么这个payload就很好理解了.</p><p>我们来看一下，一共有哪些参数</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fi7frqjj20t60fjn3c.jpg" alt=""><br>参数还挺多的，可以看到很多参数都是固定的，如账号，密码，时间戳，等等</p><p>变动的有两个 client_id,signature</p><h2 id="开始找参数"><a href="#开始找参数" class="headerlink" title="开始找参数"></a>开始找参数</h2><p><code>authorization</code>：</p><p>我们在chrome内，直接按ctrl+shift+f(全局搜索，搜索js,css这些)，可以看到已经搜索到了，并且是直接写在js里面的，然后重新随便换个账号再抓一次包，发现authorization 的值还是固定的，所以说明authorization 是直接写在js里面的，不是动态修改的(那么authorization 的值我们就已经找到了）</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3filrwi9j20kr053tbj.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3firqfpjj20gc09lq71.jpg" alt=""><br><code>cookie</code>：</p><p>在登陆之前，就发现cookie的值不为空，说明肯定打开网页后就有set-cookie的操作了，我们想验证的话，先打开一个无痕浏览器（主要是为了把之前的cookie全部清空，避免干扰），然后打开<a href="http://zhihu.com/" rel="external nofollow noopener noreferrer" target="_blank">http://zhihu.com</a>，我们发现他有几次set-cookie的动作</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fj4op6sj20rm06f78i.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fjayv50j20qe06tgqo.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fjjbul8j20ty06yjxl.jpg" alt=""><br>那我们想要模拟的话，很简单的方法是直接使用requests.session</p><p><code>x-udid,x-sxrftoken</code>:</p><p>一般这种验证参数都会在网页源代码里面,所以直接查看网页源代码</p><p>可以看到已经找到了,后续就是如何把这个找出来而已，可以使用正则，或者xpath定位到</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fjyl8ltj20tq09rnfl.jpg" alt=""><br><code>client_id</code>:</p><p>你会发现client_id与上面的authorization 一模一样</p><p><code>signature</code>:</p><p>还是使用ctrl+shift+f 全局搜索</p><p>发现找到了，但是参数是js动态生成的…</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fkaq7tzj20x909wah2.jpg" alt=""><br>主要是找到如何加密的，然后使用Python模拟出来</p><p>第一步：下载这个js，格式化（让代码好看一些）</p><p>第二步：使用fiddle替换掉原来的js，使用刚刚格式化的js</p><p>第三步：慢慢调试。。。直到找到如何生成的…</p><p>大概步骤是这样</p><p>但是假如你js像我一样很渣的话，你可以直接找到这段加密的js，然后Python执行这段js就可以了。。。</p><h2 id="上面呢，我们把该找的参数都找到了，接着只要模拟发送就可以了"><a href="#上面呢，我们把该找的参数都找到了，接着只要模拟发送就可以了" class="headerlink" title="上面呢，我们把该找的参数都找到了，接着只要模拟发送就可以了"></a>上面呢，我们把该找的参数都找到了，接着只要模拟发送就可以了</h2><p><a href="https://github.com/jin10086/pachong/blob/master/zhihulogin.py" rel="external nofollow noopener noreferrer" target="_blank">知乎登陆代码在这</a></p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      原因
为啥要写这一篇文章呢？
（主要是qq群内有人在模拟登陆知乎，一直不成功）然后我抓包看了下，发现知乎登陆页已经改版了，而且难度大大提高了。

开始抓包
首先内，还是打开知乎首页，然后输入账号密码，登陆（记得输错密码） 

这样我们就可以看到请求头了（请求头如下）

我们发现有这几个请求头和正常的不一样（红色框中的）

 1. authorization （感觉应该是js生成的，后面再看
 2. Content-Type （后面多了boundary=xxx 这种,那这种是啥意思呢,后面和请求参数一起看
 3. cookie：这个要注意,登陆前cookie就不为空，说明之前肯定有set-coo
    
    </summary>
    
      <category term="爬虫" scheme="https://jin10086.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫实战" scheme="https://jin10086.github.io/tags/%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98/"/>
    
      <category term="模拟登陆知乎" scheme="https://jin10086.github.io/tags/%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86%E7%9F%A5%E4%B9%8E/"/>
    
  </entry>
  
  <entry>
    <title>请正确使用http状态码，谢谢！</title>
    <link href="https://jin10086.github.io/2018/02/03/%E8%AF%B7%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8http%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%8C%E8%B0%A2%E8%B0%A2%EF%BC%81/"/>
    <id>https://jin10086.github.io/2018/02/03/请正确使用http状态码，谢谢！/</id>
    <published>2018-02-03T10:13:25.000Z</published>
    <updated>2018-04-04T07:12:10.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近，由于某些特别原因。打开一些网址一直显示404，<br>想请问下，xx站的程序员，能不能按照http协议来返回呢？</p><h2 id="什么是http状态码451"><a href="#什么是http状态码451" class="headerlink" title="什么是http状态码451"></a>什么是http状态码451</h2><blockquote><p>根据定义，HTTP 451错误代码状态出现，不代表这个地址是否存在，而代表该网页可能对于国家安全产生危险，或是该网页可能违反著作权、隐私权、亵渎神明或其他法律或法院命令。<br>该响应代码有如下的性质：<br>除非另外指明，否则这个响应代码是可以被缓存的。<br>必须携带一个带有一个Link头部，列出要求封禁该地址的实体URI；且应带有一个”rel”字段，值应为”blocked-by”[1]。<br>简单的讲 就是由于某些政治原因，所以，该页面不予访问</p></blockquote><h2 id="HTTP451的来源"><a href="#HTTP451的来源" class="headerlink" title="HTTP451的来源"></a>HTTP451的来源</h2><blockquote><p>本代码于2013年由提姆·布雷（Tim Bray）正式提出，主要基于博客Terence Eden的文章所提出的非正式提案[2]。2015年12月18日，此代码由国际网络工程研究团队通过[3]。<br>451这个代码源于1953年的反乌托邦小说《华氏451度》(纸的燃点为华氏451度)，在这部小说中，所有书籍是违禁品[4]。相比较HTTP 403代码，451可更好描述一种由于法律规定或受权威部门要求而导致的封禁状态[5]</p></blockquote><h2 id="一个示例"><a href="#一个示例" class="headerlink" title="一个示例"></a>一个示例</h2><p>某地一用户以GET方式请求<a href="http://example.org的/index.php路径：" rel="external nofollow noopener noreferrer" target="_blank">http://example.org的/index.php路径：</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /index.php HTTP/1.1</span><br><span class="line">Host: www.example.org</span><br></pre></td></tr></table></figure><p>由于用户所在地的某项法律规定，网站不可以向该地区用户返回这个页面，所以服务器做出回应，设置了有效期为一年的缓存头部，并在Link头部中加入了指定的政府部门URL<code>http://www.xxx.gov.tld</code><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 451 Unavailable For Legal Reasons</span><br><span class="line">Link: <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.xxx.gov.tld</span>&gt;</span>; rel="blocked-by"</span><br><span class="line">Cache-control: max-age=31536000; public</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>因法律原因不可用<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>HTTP/1.1 451 因法律原因，本页面不可用<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>根据《某法》第某条之规定，本网站页面对来自某地的访客不可用。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fco2j5kj219m0b3dtv.jpg" alt=""></p><p>文章参考于 维基百科 <a href="https://zh.wikipedia.org/wiki/HTTP_451" rel="external nofollow noopener noreferrer" target="_blank">https://zh.wikipedia.org/wiki/HTTP_451</a></p><p><a href="https://tools.ietf.org/html/rfc7725" rel="external nofollow noopener noreferrer" target="_blank">RFC 7725</a> - HTTP 451的正式RFC文件</p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      背景
最近，由于某些特别原因。打开一些网址一直显示404，
想请问下，xx站的程序员，能不能按照http协议来返回呢？

什么是http状态码451
根据定义，HTTP 451错误代码状态出现，不代表这个地址是否存在，而代表该网页可能对于国家安全产生危险，或是该网页可能违反著作权、隐私权、亵渎神明或其他法律或法院命令。
该响应代码有如下的性质：
除非另外指明，否则这个响应代码是可以被缓存的。
必须携带一个带有一个Link头部，列出要求封禁该地址的实体URI；且应带有一个”rel”字段，值应为”blocked-by”[1]。
简单的讲 就是由于某些政治原因，所以，该页面不予访问

HTTP451
    
    </summary>
    
      <category term="爬虫" scheme="https://jin10086.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="http状态吗" scheme="https://jin10086.github.io/tags/http%E7%8A%B6%E6%80%81%E5%90%97/"/>
    
      <category term="http451" scheme="https://jin10086.github.io/tags/http451/"/>
    
  </entry>
  
  <entry>
    <title>知乎想法抽奖专用</title>
    <link href="https://jin10086.github.io/2018/02/03/%E7%9F%A5%E4%B9%8E%E6%83%B3%E6%B3%95%E6%8A%BD%E5%A5%96%E4%B8%93%E7%94%A8/"/>
    <id>https://jin10086.github.io/2018/02/03/知乎想法抽奖专用/</id>
    <published>2018-02-03T10:09:21.000Z</published>
    <updated>2018-04-04T07:12:10.673Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>很久没有更新专栏了，写一个好玩的把（刚好最近很多人有需求）<br>废话不多说，直接看代码把（接口是通过抓取手机app的包获取的，不会的话请看<a href="https://zhuanlan.zhihu.com/p/26785815" rel="external nofollow noopener noreferrer" target="_blank">抓取手机app的数据（摩拜单车）</a>）</p><h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><ol><li>打开想法详情页<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3f7feuo5j20yi1pcno3.jpg" alt=""></li><li>点击复制链接<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3f7yjk4dj20k00zk7hc.jpg" alt=""></li><li><code>python zhihu.py --url 刚刚复制的网址</code></li></ol><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟浏览器头</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'host'</span>: <span class="string">"api.zhihu.com"</span>,</span><br><span class="line">    <span class="string">'accept'</span>: <span class="string">"*/*"</span>,</span><br><span class="line">    <span class="string">'x-app-za'</span>: <span class="string">"OS=iOS&amp;Release=10.3.3&amp;Model=iPhone8,2&amp;VersionName=4.1.0&amp;VersionCode=683&amp;Width=1242&amp;Height=2208&amp;DeviceType=Phone&amp;Brand=Apple&amp;OperatorType=46001"</span>,</span><br><span class="line">    <span class="string">'x-udid'</span>: <span class="string">"AHCAH2SzkApLBWvOUMZ7s9hG-Zh-_NhtVCM="</span>,</span><br><span class="line">    <span class="string">'x-app-versioncode'</span>: <span class="string">"683"</span>,</span><br><span class="line">    <span class="string">'accept-language'</span>: <span class="string">"zh-Hans-CN;q=1, en-CN;q=0.9"</span>,</span><br><span class="line">    <span class="string">'accept-encoding'</span>: <span class="string">"gzip, deflate"</span>,</span><br><span class="line">    <span class="string">'x-api-version'</span>: <span class="string">"3.0.64"</span>,</span><br><span class="line">    <span class="string">'authorization'</span>: <span class="string">"Bearer gt2.0AAAAAAX1feoKkLNkH4BwAAAAAAtNVQJgAgBgPzk1-59vTbuXI60W0XlSl-wNBg=="</span>,</span><br><span class="line">    <span class="string">'x-network-type'</span>: <span class="string">"WiFi"</span>,</span><br><span class="line">    <span class="string">'user-agent'</span>: <span class="string">"osee2unifiedRelease/4.1.0 (iPhone; iOS 10.3.3; Scale/3.00)"</span>,</span><br><span class="line">    <span class="string">'x-app-build'</span>: <span class="string">"release"</span>,</span><br><span class="line">    <span class="string">'x-app-version'</span>: <span class="string">"4.1.0"</span>,</span><br><span class="line">    <span class="string">'x-suger'</span>: <span class="string">"SURGVj0wNDA5NjgxMS01NTI5LTRDQUQtQUEzNi1FRkI2M0VDQThDOEE7SURGQT01MDM2NDdEMy01QTlDLTRFMjItODA5NS1FRkUyM0Y5Mzg5QzM="</span>,</span><br><span class="line">    <span class="string">'cookie'</span>: <span class="string">"aliyungf_tc=AQAAAH4w9XP89AUAWgqDdYQRcynwI6xp; q_c1=97515fa2381f48a7b6ef8d46de8bc7be|1505561812000|1505561812000; z_c0=gt2.0AAAAAAX1feoKkLNkH4BwAAAAAAtNVQJgAgBgPzk1-59vTbuXI60W0XlSl-wNBg==; _xsrf=a31505e0-0f69-440b-b357-30fffc9838bd; cap_id=\"MzQ2NGE0NThiMmVjNDU3MmE5MzVhYzE0OGYyMTYzYTI=|1505561809|0c36cb283969855952e9e895b77211fd292c0df7\"; l_cap_id=\"ODE3YzMwODM5ZTE0NDdjN2IxY2UyZDdiYjQ1MGYzNDg=|1505561809|6f707b1bf6c0a0ebb6391d0c421ac06e49ceca3b\"; r_cap_id=\"ODZlYTZmNGZhYzU3NDgwOGE4YzUyOWI5OTBmMzA3NjQ=|1505561809|05c714d01ee35a0a6c96b0c330d4f10434fec8bc\""</span>,</span><br><span class="line">    <span class="string">'cache-control'</span>: <span class="string">"no-cache"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'get url ---&#123;&#125;'</span>.format(url))</span><br><span class="line">    z = requests.get(url, headers=headers, verify=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> z.json()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(url)</span>:</span></span><br><span class="line">    jsdata = get(url)</span><br><span class="line">    info = []</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> jsdata[<span class="string">'data'</span>]:</span><br><span class="line">            <span class="keyword">if</span> i[<span class="string">'action_type'</span>] == <span class="string">'repin'</span>:</span><br><span class="line">                info.append(&#123;</span><br><span class="line">                    <span class="string">'url'</span>: i[<span class="string">'member'</span>][<span class="string">'url'</span>],</span><br><span class="line">                    <span class="string">'name'</span>: i[<span class="string">'member'</span>][<span class="string">'name'</span>],</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment"># print(i['member']['url'], print(i['member']['name']))</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> jsdata[<span class="string">'paging'</span>][<span class="string">'is_end'</span>]:</span><br><span class="line">            jsdata = get(jsdata[<span class="string">'paging'</span>][<span class="string">'next'</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> info</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">'知乎想法抽奖'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--url'</span>, type=str, default=<span class="keyword">None</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    baseurl = <span class="string">'https://api.zhihu.com/pins/&#123;&#125;/actions?limit=20&amp;offset=0'</span></span><br><span class="line">    url = args.url</span><br><span class="line">    pin = url.split(<span class="string">'/'</span>)[<span class="number">-1</span>]</span><br><span class="line">    <span class="comment"># 修复 当网址分享到qq的时候 有后缀的问题，如https://www.zhihu.com/pin/900498393586094080?utm_source=qq</span></span><br><span class="line">    pin_id = re.search(<span class="string">'\d+'</span>,pin)[<span class="number">0</span>]</span><br><span class="line">    url = baseurl.format(pin_id)</span><br><span class="line">    info = run(url)</span><br><span class="line">    print(len(info))</span><br><span class="line">    print(<span class="string">'********本次抽奖获得者为********'</span>)</span><br><span class="line">    print(choice(info))</span><br><span class="line">    print(<span class="string">'********本次抽奖获得者为********'</span>)</span><br></pre></td></tr></table></figure><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      背景
很久没有更新专栏了，写一个好玩的把（刚好最近很多人有需求）
废话不多说，直接看代码把（接口是通过抓取手机app的包获取的，不会的话请看抓取手机app的数据（摩拜单车））

怎么用
 1. 打开想法详情页
    
 2. 点击复制链接
    
 3. python zhihu.py --url 刚刚复制的网址

代码如下
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
    
    </summary>
    
      <category term="爬虫" scheme="https://jin10086.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫实战" scheme="https://jin10086.github.io/tags/%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98/"/>
    
      <category term="知乎想法抽奖" scheme="https://jin10086.github.io/tags/%E7%9F%A5%E4%B9%8E%E6%83%B3%E6%B3%95%E6%8A%BD%E5%A5%96/"/>
    
  </entry>
  
  <entry>
    <title>如何让爬虫更快</title>
    <link href="https://jin10086.github.io/2018/02/03/%E5%A6%82%E4%BD%95%E8%AE%A9%E7%88%AC%E8%99%AB%E6%9B%B4%E5%BF%AB/"/>
    <id>https://jin10086.github.io/2018/02/03/如何让爬虫更快/</id>
    <published>2018-02-03T09:56:05.000Z</published>
    <updated>2018-04-04T07:12:10.671Z</updated>
    
    <content type="html"><![CDATA[<p>本文章属于爬虫入门到精通系统教程<a href="https://zhuanlan.zhihu.com/pachong" rel="external nofollow noopener noreferrer" target="_blank">第十一讲</a></p><p>在前面的教程中，我们已经学会了如何抓取一个网页，可是，当我需要抓取的数据足够多的时候，应该如何让我抓取的速度更快呢？</p><p>最简单的方法就是使用多进程.</p><h2 id="什么是多线程"><a href="#什么是多线程" class="headerlink" title="什么是多线程"></a>什么是多线程</h2><p> 多线程（英语：multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。</p><h2 id="使用多线程的好处"><a href="#使用多线程的好处" class="headerlink" title="使用多线程的好处"></a>使用多线程的好处</h2><ul><li>使用线程可以把占据时间长的程序中的任务放到后台去处理<ul><li>用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度</li><li>程序的运行速度可能加快</li><li><strong>在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下可以释放一些珍贵的资源如内存占用等等。</strong></li><li>多线程技术在IOS软件开发中也有举足轻重的位置。</li></ul></li></ul><h2 id="在python中使用多线程"><a href="#在python中使用多线程" class="headerlink" title="在python中使用多线程"></a>在python中使用多线程</h2><h3 id="安装方法："><a href="#安装方法：" class="headerlink" title="安装方法："></a>安装方法：</h3><p><code>pip install futures</code></p><p>注意：由于本系列教程是基于python2的，所以需要安装，如果你使用的是python3 ，在标准库里已经有这个模块了。直接用就行</p><h3 id="concurrent的介绍"><a href="#concurrent的介绍" class="headerlink" title="concurrent的介绍"></a>concurrent的介绍</h3><p>concurrent.futures 模块为异步执行可调用的对象提供了一个高级的接口。</p><p>异步执行可以通过线程来实现，使用 <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" rel="external nofollow noopener noreferrer" target="_blank">ThreadPoolExecutor</a> 模块，或者使用 <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" rel="external nofollow noopener noreferrer" target="_blank">ProcessPoolExecutor</a> 模块通过分离进程来实现。两种实现都有同样的接口，他们都是通过抽象类 <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor" rel="external nofollow noopener noreferrer" target="_blank">Executor</a> 来定义的。</p><h3 id="Executor-对象"><a href="#Executor-对象" class="headerlink" title="Executor 对象"></a>Executor 对象</h3><p> <code>class concurrent.futures.Executor</code></p><p> 这是一个抽象类，用来提供方法去支持异步地执行调用，它不应该被直接调用，而是应该通过具体的子类来使用。</p><p> <code>submit(fn, *args, **kwargs)</code><br> 可调用对象的调度器，<code>fn</code>参数将会以<code>fn(*args, **kwargs)</code>的形式来调用，同时返回一个 Future 对象代表了可调用对象的执行情况。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">1</span>) <span class="keyword">as</span> executor:</span><br><span class="line">  future = executor.submit(pow, <span class="number">323</span>, <span class="number">1235</span>)</span><br><span class="line">  print(future.result())</span><br></pre></td></tr></table></figure><p> <code>map(func, *iterables, timeout=None, chunksize=1)</code></p><p> 和<code>map(func, *iterables)</code>函数的作用基本相同，除了<code>func</code>是被异步执行的，而且几个对于<code>func</code>调用可能是同时执行的。这个函数返回的迭代器调用<code>__next__()</code>方法的时候，如果在<code>timeout</code>秒内结果不可用，那么迭代器将会从原始调用的函数向<code>Executor.map()</code>抛出一个<code>concurrent.futures.TimeoutError</code>的异常。<code>timeout</code>既能是一个整数，也能是一个浮点数。如果<code>timeout</code>没有指定的话或者等于 None 的话，那么等待时间就没有限制。如果调用函数抛出了一个异常，那么当迭代器取到这个函数的时候，异常将会被抛出。<br> 当使用<code>ProcessPoolExecutor</code>的时候，这个方法将<code>iterables</code>切成许多块，然后将这些内容作为分离的任务提交到进程池中。每个块的大概的尺寸能够通过<code>chunksize</code>(大于0的正整数)的参数来指定。当<code>iterables</code>非常大的时候，和<code>chunksize</code>默认等于1相比，将<code>chunksize</code>设置为一个很大的值，将会显著地提升性能。在使用<code>ThreadPoolExecutor</code>的情况下，<code>chunksize</code>的大小没有影响。</p><p> Python 3.5新增功能：添加了<code>chunksize</code>参数</p><p> <code>shutdown(wait=True)</code></p><p> 告诉执行器，当当前阻塞的 futures 执行完了以后，它应该释放所有它使用的资源。在<code>shutdown</code>函数之后再来调用<code>Executor.submit()</code>和<code>Executor.map()</code>将会抛出<code>RuntimeError</code></p><p> 如果<code>wait</code>等于 True 的话，这个方法不会立即返回，而直到所有阻塞的 futures 都返回，而且和这个执行器所有相关的资源都被释放以后，这个函数才会返回。 如果<code>wait</code>设置为 False ，那么这个方法会立刻返回，而和这个执行器所有相关的资源只有等到所有阻塞的 futures 都执行完以后才会被释放。而无论<code>wait</code>参数的值是什么，整个 Python 程序都会等到所有阻塞的 futures 执行完毕以后才会退出。</p><p> <strong>通过<code>with</code>语句，可以避免明确地来调用这个方法，它在执行完以后将会自动关闭<code>Executor</code>。</strong>(调用 Executor.shutdown() 时<code>wait</code>会被设置为True，这将会等待所有 future 执行完毕)</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">4</span>) <span class="keyword">as</span> e:</span><br><span class="line">  e.submit(shutil.copy, <span class="string">'src1.txt'</span>, <span class="string">'dest1.txt'</span>)</span><br><span class="line">  e.submit(shutil.copy, <span class="string">'src2.txt'</span>, <span class="string">'dest2.txt'</span>)</span><br><span class="line">  e.submit(shutil.copy, <span class="string">'src3.txt'</span>, <span class="string">'dest3.txt'</span>)</span><br><span class="line">  e.submit(shutil.copy, <span class="string">'src4.txt'</span>, <span class="string">'dest4.txt'</span>)</span><br></pre></td></tr></table></figure><h3 id="ThreadPoolExecutor-重点"><a href="#ThreadPoolExecutor-重点" class="headerlink" title="ThreadPoolExecutor(重点)"></a>ThreadPoolExecutor(重点)</h3><p><code>ThreadPoolExecutor</code>是<code>Executor</code>的子类，使用一个线程池去异步地执行调用。</p><p> <code>class concurrent.futures.ThreadPoolExecutor(max_workers=None)</code></p><p> 一个<code>Executor</code>的子类，使用线程池中最多<code>max_workers</code>个线程去异步地执行回调。<br> Python 3.5中的改变：如果<code>max_workers</code>参数为None或者没有给定，那么它将会被默认设置成为机器的CPU核数乘5。这里假设<code>ThreadPoolExecutor</code>经常被用来执行IO密集型的工作而不是CPU密集型的工作，工作者的个数应该比<code>ProcessPoolExecutor</code>的工作者的个数要多。</p><h3 id="ThreadPoolExecutor-例子"><a href="#ThreadPoolExecutor-例子" class="headerlink" title="ThreadPoolExecutor 例子"></a>ThreadPoolExecutor 例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">URLS = [<span class="string">'http://www.foxnews.com/'</span>,</span><br><span class="line"><span class="string">'http://www.cnn.com/'</span>,</span><br><span class="line"><span class="string">'http://europe.wsj.com/'</span>,</span><br><span class="line"><span class="string">'http://www.bbc.co.uk/'</span>,</span><br><span class="line"><span class="string">'http://some-made-up-domain.com/'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取一个单页，同时报告URL和内容</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_url</span><span class="params">(url, timeout)</span>:</span></span><br><span class="line">  <span class="keyword">with</span> urllib.request.urlopen(url, timeout=timeout) <span class="keyword">as</span> conn:</span><br><span class="line">  <span class="keyword">return</span> conn.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们通过with语句来确保线程能够被及时地清理，</span></span><br><span class="line"><span class="comment"># 这边max_workers=5，表示最多同时有5个线程去执行</span></span><br><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</span><br><span class="line">  <span class="comment"># 字典生成器,使用的方法是`executor.submit()`</span></span><br><span class="line">  future_to_url = &#123;executor.submit(load_url, url, <span class="number">60</span>): url <span class="keyword">for</span> url <span class="keyword">in</span> URLS&#125;</span><br><span class="line">  <span class="string">'''</span></span><br><span class="line"><span class="string">  字典生成器用for循环实现的话，如下</span></span><br><span class="line"><span class="string">  future_to_url = &#123;&#125;</span></span><br><span class="line"><span class="string">  for url in URLS:</span></span><br><span class="line"><span class="string">  future = executor.submit(load_url, url, 60)</span></span><br><span class="line"><span class="string">  future_to_url[future] = url</span></span><br><span class="line"><span class="string">  '''</span></span><br><span class="line">  <span class="keyword">for</span> future <span class="keyword">in</span> concurrent.futures.as_completed(future_to_url):</span><br><span class="line">  url = future_to_url[future]</span><br><span class="line">  <span class="comment"># 这边的future就是 通过`Executor.submit()`函数来创建的。</span></span><br><span class="line">  <span class="comment">#有以下常用方法方法</span></span><br><span class="line">  <span class="comment"># future.result(),返回由相关回调产生的结果，在本案列中，返回函数`load_url`的结果</span></span><br><span class="line">  <span class="comment"># future.exception() 返回由相关回调抛出的异常，如果没有异常则返回`None`</span></span><br><span class="line">  <span class="comment"># 更多future对象介绍请看下文</span></span><br><span class="line">  <span class="keyword">if</span> future.exception() <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">    print(<span class="string">'%r generated an exception: %s'</span> % (url,future.exception()))</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'%r page is %d bytes'</span> % (url, len(future.result())))</span><br></pre></td></tr></table></figure><h3 id="Future-对象"><a href="#Future-对象" class="headerlink" title="Future 对象"></a>Future 对象</h3><p>Future 类封装了一个可调用对象的异步执行过程，Future 对象是通过<code>Executor.submit()</code>函数来创建的。</p><p> <code>class concurrent.futures.Future</code></p><p> 封装了一个可调用对象的异步执行过程。Future 实例是通过<code>Executor.submit()</code>方法来创建的，而且不应该被直接创建，除非用来测试。</p><p> <code>cancel()</code><br> 尝试去取消相关回调，如果这个回调正在被执行，而且不能被取消，那么这个方法将会返回<code>False</code>，否则这个方法将会取消相应的回调并且返回<code>True</code></p><p> <code>cancelled()</code><br> 如果相关回调被成功取消了，那么这个方法将会返回<code>True</code></p><p> <code>running()</code><br> 如果相关回调当前正在被执行而且无法取消，那么将会返回<code>True</code></p><p> <code>done()</code><br> 如果相关的回调被成功地取消或者已经运行完毕那么将返回<code>True</code></p><p> <code>result(timeout=None)</code><br> 返回由相关回调产生的结果。如果这个回调还没有被完成那么这个方法将会等待<code>timeout</code>秒。如果这个回调在<code>timeout</code>秒内还没有返回，一个<code>concurrent.futures.TimeoutError</code>的异常将会被抛出。<code>timeout</code>能够被设置成一个整数或者一个浮点数。如果<code>timeout</code>没有被设置或者其值为<code>None</code>，那么等待时间将没有限制。</p><p> 如果这个 future 在完成之前被取消了，那么将会抛出一个<code>CancelledError</code>的异常。<br> 如果相关的回调抛出了一个异常，那么这个方法也会相应地抛出这个异常。</p><p> <code>exception(timeout=None)</code><br> 返回由相关回调抛出的异常。如果相关回调还没有被完成那么这个方法将会等待<code>timeout</code>秒。如果相关回调在<code>timeout</code>秒内还没有被完成，那么将会抛出一个<code>concurrent.futures.TimeoutError</code>的异常。<code>timeout</code>能够被设置成一个整数或者一个浮点数。如果<code>timeout</code>没有被设置或者其值为<code>None</code>，那么等待时间将没有限制。</p><p>如果这个 future 在完成之前被取消了，那么将会抛出一个<code>CancelledError</code>的异常。<br>如果相关回调被完成了且没有抛出异常，None将会被返回。</p><p><code>add_done_callback(fn)</code><br>将可调用对象<code>fn</code>连接到这个 future 上，<code>fn</code>将会在 future 被取消或者结束运行时被调用，而且仅有相关 future 这一个参数。<br>添加的可调用对象将会以它们被添加的顺序来调用，而且总是在添加它们的那个进程的所属的线程中调用(译者注，可以参考<a href="https://gist.github.com/bwangel23/8c4bd585f6e54c6ec6de336dd73abbe3" rel="external nofollow noopener noreferrer" target="_blank">这段代码</a>)。如果相关调用<code>fn</code>抛出了一个<code>Exception</code>子类的异常，它将会被记录和忽略。如果相关调用<code>fn</code>抛出了一个<code>BaseException</code>子类的异常，那么行为是未定义的。<br>如果相关的 future 已经被完成了或者取消了，<code>fn</code>将会被立刻调用。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> cPickle <span class="keyword">as</span> pickle</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line">client = MongoClient()</span><br><span class="line">db = client.loc</span><br><span class="line">collection = db.mobai1</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_url</span><span class="params">(url, params, timeout, headers=None)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> requests.get(url, params=params, timeout=timeout, headers=headers).json()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getloc</span><span class="params">()</span>:</span></span><br><span class="line">    allloc = []</span><br><span class="line">    <span class="string">"""利用高德地图api获取上海所有的小区坐标</span></span><br><span class="line"><span class="string">    http://lbs.amap.com/api/webservice/guide/api/search/#text</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        url = <span class="string">'http://restapi.amap.com/v3/place/text'</span></span><br><span class="line">        param = &#123;</span><br><span class="line">            <span class="string">'key'</span>: <span class="string">'22d6f93f929728c10ed86258653ae14a'</span>,</span><br><span class="line">            <span class="string">'keywords'</span>: <span class="string">u'小区'</span>,</span><br><span class="line">            <span class="string">'city'</span>: <span class="string">'021'</span>,</span><br><span class="line">            <span class="string">'citylimit'</span>: <span class="string">'true'</span>,</span><br><span class="line">            <span class="string">'output'</span>: <span class="string">'json'</span>,</span><br><span class="line">            <span class="string">'page'</span>: <span class="string">''</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        future_to_url = &#123;executor.submit(load_url, url, merge_dicts(param, &#123;<span class="string">'page'</span>: i&#125;), <span class="number">60</span>): url <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">46</span>)&#125;</span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> futures.as_completed(future_to_url):</span><br><span class="line">            <span class="keyword">if</span> future.exception() <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">print</span> future.exception()</span><br><span class="line">            <span class="keyword">elif</span> future.done():</span><br><span class="line">                data = future.result()[<span class="string">'pois'</span>]</span><br><span class="line">                allloc.extend([x[<span class="string">'location'</span>] <span class="keyword">for</span> x <span class="keyword">in</span> data])</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'allloc1.pk'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            pickle.dump(allloc, f, <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_dicts</span><span class="params">(*dict_args)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">   可以接收1个或多个字典参数</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    result = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> dictionary <span class="keyword">in</span> dict_args:</span><br><span class="line">        result.update(dictionary)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mobai</span><span class="params">(loc)</span>:</span></span><br><span class="line">    allmobai = []</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        url = <span class="string">'https://mwx.mobike.com/mobike-api/rent/nearbyBikesInfo.do'</span></span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Mobile/14E304 MicroMessenger/6.5.7 NetType/WIFI Language/zh_CN'</span>,</span><br><span class="line">            <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>,</span><br><span class="line">            <span class="string">'Referer'</span>: <span class="string">'https://servicewechat.com/wx80f809371ae33eda/23/page-frame.html'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">'longitude'</span>: <span class="string">''</span>,</span><br><span class="line">            <span class="string">'latitude'</span>: <span class="string">''</span>,</span><br><span class="line">            <span class="string">'citycode'</span>: <span class="string">'021'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        future_to_url = &#123;</span><br><span class="line">            executor.submit(load_url, url, merge_dicts(data, &#123;<span class="string">'longitude'</span>: i.split(<span class="string">','</span>)[<span class="number">0</span>]&#125;, &#123;<span class="string">'latitude'</span>: i.split(<span class="string">','</span>)[<span class="number">1</span>]&#125;),</span><br><span class="line">                            <span class="number">60</span>,headers): url <span class="keyword">for</span> i <span class="keyword">in</span> loc&#125;</span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> futures.as_completed(future_to_url):</span><br><span class="line">            <span class="keyword">if</span> future.exception() <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">print</span> future.exception()</span><br><span class="line">            <span class="keyword">elif</span> future.done():</span><br><span class="line">                data = future.result()[<span class="string">'object'</span>]</span><br><span class="line">                allmobai.extend(data)</span><br><span class="line">                <span class="comment"># 存入mongodb</span></span><br><span class="line">                result = collection.insert_many(data)</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>完本编文章，你应该学会“如何使用多线程抓取网页”<br>最后所有代码都在<a href="https://github.com/jin10086/pachong/blob/master/mobai.py" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/jin10086/pachong/blob/master/mobai.py</a></p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      本文章属于爬虫入门到精通系统教程第十一讲

在前面的教程中，我们已经学会了如何抓取一个网页，可是，当我需要抓取的数据足够多的时候，应该如何让我抓取的速度更快呢？

最简单的方法就是使用多进程.

什么是多线程
 多线程（英语：multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。

使用多线程的好处
 * 使用线程可以把占据时间长的程序中的任务放到后台去处理 * 用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度
    *
    
    </summary>
    
      <category term="爬虫" scheme="https://jin10086.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="多线程" scheme="https://jin10086.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="多进程" scheme="https://jin10086.github.io/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>抓取手机app的数据（摩拜单车）</title>
    <link href="https://jin10086.github.io/2018/02/03/%E6%8A%93%E5%8F%96%E6%89%8B%E6%9C%BAapp%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%88%E6%91%A9%E6%8B%9C%E5%8D%95%E8%BD%A6%EF%BC%89/"/>
    <id>https://jin10086.github.io/2018/02/03/抓取手机app的数据（摩拜单车）/</id>
    <published>2018-02-03T09:42:29.000Z</published>
    <updated>2018-04-04T07:12:10.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前几天有人私信我，问能不能帮忙抓取摩拜单车的数据。。。<br>我想着授人以鱼不如授人以渔，所以本次我们就讲讲如何抓取手机app的内容吧<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3eefpyn0j20k703gq4h.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3eenva64j20zq049tch.jpg" alt=""></p><h2 id="fiddle的安装与配置"><a href="#fiddle的安装与配置" class="headerlink" title="fiddle的安装与配置"></a>fiddle的安装与配置</h2><p>抓手机包我用的是fiddle。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>先在下载页面下载—&gt;<a href="https://www.telerik.com/download/fiddler" rel="external nofollow noopener noreferrer" target="_blank">Download Fiddler Web Debugging Tool for Free by Telerik</a></p><p>选择你“准备用fiddle来干嘛”</p><p>你的邮箱</p><p>以及同意“最终用户许可协议”就可以下载了</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3efqsytmj20k00b9diq.jpg" alt=""><br>下载后按照提示安装就可以了。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li>点击tool-&gt;telerik fiddler options…</li><li><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3egyj6e7j20gk08mtbx.jpg" alt=""></li><li>点击connections，然后勾选 <code>allow remote computers to connect</code><br>记住这边的端口号（<code>8888</code>）</li><li><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3ehhpvhej20fd0aawjg.jpg" alt=""></li></ul><h2 id="抓包前设置"><a href="#抓包前设置" class="headerlink" title="抓包前设置"></a>抓包前设置</h2><ol><li>首先确保电脑和手机连在同一个WiFi下面</li><li>打开fiddle</li><li>获取电脑ip<ol><li>打开cmd命令行</li><li>输入ipconfig,如图所示，192.168.31.146就是我的ip地址<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3eigqm4wj20rf0e80vp.jpg" alt=""></li></ol></li><li>打开手机WiFi设置，找到你当前链接的WiFi<ol><li>我当前链接的是Xiaomi_E172_5G</li><li><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3ej0khpjj20yi1pcwrg.jpg" alt=""></li></ol></li><li>设置代理服务器为你电脑的ip，端口号为上面设置的端口号（默认为8888）<ol><li><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3ejpdwshj20yi1pcakm.jpg" alt=""></li></ol></li><li>安装https证书<ol><li>在手机浏览器上打开 你电脑ip:你设置的端口号</li><li>我的是192.168.31.146:8888</li><li>点击框框处安装证书<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3ekjddrzj20hs0di40s.jpg" alt=""></li></ol></li><li>设置fiddle监听所有请求<ol><li>选择all process<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3el4w4dij20rs0d5wil.jpg" alt=""></li></ol></li></ol><h2 id="开始抓包"><a href="#开始抓包" class="headerlink" title="开始抓包"></a>开始抓包</h2><p>打开摩拜单车app<br>然后你会看到定位的时候一辆车也没有。。。<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3em8t60rj20k00zkkbs.jpg" alt=""><br>打开个人详情页还提示“抱歉，服务暂不可用。。。”<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3emjgaggj20k00zkajb.jpg" alt=""><br>这是因为摩拜有防抓取限制（我猜是检测，如果有使用代理的话，直接让你用不了。。。）<br>那这样的话我们就没办法抓到么？？？<br>因为我之前还用过摩拜的小程序，所以我们抓抓微信小程序试试看<br>打开摩拜单车的小程序<br>我们看到已经定位了。。，并且把附件的单车都显示出来了<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3emy2bh2j20k00zkkgd.jpg" alt=""></p><p>我们可以多移动我们的位置，然后等有把附近的车显示出来<br>可以看到fiddle上面已经有好多请求了<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3enb2gqyj20nm09qago.jpg" alt=""><br>那么如何找到摩拜的那一条呢。。。<br>很简单，看单词就好。。。<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3enl8gw7j21cf0p54gg.jpg" alt=""></p><p>mobike-api。。。这很明显就是我们要找的请求<br>请求头如下图所示，方法是post<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3eny90p9j20hv0br441.jpg" alt=""><br>参数如下图<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3eo78v3uj20np080n05.jpg" alt=""><br>返回值因为我看到是json的格式了，所以直接以json的格式看。<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3eoogktnj20of0a077i.jpg" alt=""></p><h2 id="模拟发送"><a href="#模拟发送" class="headerlink" title="模拟发送"></a>模拟发送</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment"># 如果headers里面没有referer则会访问异常</span></span><br><span class="line"><span class="comment"># referer表示上一个页面是什么。</span></span><br><span class="line">headers = &#123;</span><br><span class="line"><span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Mobile/14E304 MicroMessenger/6.5.7 NetType/WIFI Language/zh_CN'</span>,</span><br><span class="line"><span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>,</span><br><span class="line"><span class="string">'Referer'</span>: <span class="string">'https://servicewechat.com/wx80f809371ae33eda/23/page-frame.html'</span>,</span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">'https://mwx.mobike.com/mobike-api/rent/nearbyBikesInfo.do'</span></span><br><span class="line">data = &#123;</span><br><span class="line"><span class="string">'longitude'</span>:<span class="string">'121.1883'</span>,<span class="comment"># 经度</span></span><br><span class="line"><span class="string">'latitude'</span>:<span class="string">'31.05147'</span>, <span class="comment"># 纬度</span></span><br><span class="line"><span class="string">'citycode'</span>:<span class="string">'021'</span>,</span><br><span class="line"><span class="string">'errMsg'</span>:<span class="string">'getMapCenterLocation:ok'</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 下面必须加上verify=False,表示不验证ssl，要不然一直报错。。。</span></span><br><span class="line">z = requests.post(url,data=data,headers=headers,verify=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><p>可以看到我们已经抓取了需要的数据，那么怎么抓取整个上海的摩拜单车情况呢？？</p><p>只要获取上海的所有经纬度，然后替换上面data中的经度及纬度就可以了。。。</p><p>那么怎么获取上海的所有经纬度。。。</p><p>我发现挺难的。。。（有人拿到了请告诉我一声，谢谢）</p><p>然后我用了高德地图api的搜索功能，搜索了上海的所有小区的经纬度。一共898个，</p><p>然后查了这898个小区附件的摩拜单车情况….</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看完本编文章，你应该学会“如何抓取手机app的包”</p><p>其实挺简单的（就是你手机通过电脑上网，然后这台电脑上所有的请求都被抓下来了，那么你手机的请求自然也被抓下来了）</p><p>大家还可以试着抓抓知乎客户端的包。。。</p><p>更多fiddle的使用技巧，请善用百度、Google</p><p>最后所有代码在<a href="https://github.com/kimg1234/pachong/blob/master/mobai.py" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/kimg1234/pachong/blob/master/mobai.py</a></p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      背景
前几天有人私信我，问能不能帮忙抓取摩拜单车的数据。。。
我想着授人以鱼不如授人以渔，所以本次我们就讲讲如何抓取手机app的内容吧



fiddle的安装与配置
抓手机包我用的是fiddle。

安装
先在下载页面下载—&gt;Download Fiddler Web Debugging Tool for Free by Telerik

选择你“准备用fiddle来干嘛”

你的邮箱

以及同意“最终用户许可协议”就可以下载了


下载后按照提示安装就可以了。

配置
 * 点击tool-&gt;telerik fiddler options…
 * 
 * 点击connections，然后勾选 
    
    </summary>
    
      <category term="爬虫" scheme="https://jin10086.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="手机app抓包" scheme="https://jin10086.github.io/tags/%E6%89%8B%E6%9C%BAapp%E6%8A%93%E5%8C%85/"/>
    
      <category term="fiddle" scheme="https://jin10086.github.io/tags/fiddle/"/>
    
  </entry>
  
  <entry>
    <title>mongodb的基本使用</title>
    <link href="https://jin10086.github.io/2018/02/03/mongodb%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://jin10086.github.io/2018/02/03/mongodb的基本使用/</id>
    <published>2018-02-03T09:36:09.000Z</published>
    <updated>2018-04-04T07:12:10.670Z</updated>
    
    <content type="html"><![CDATA[<p>本文章属于<a href="https://zhuanlan.zhihu.com/p/25296437" rel="external nofollow noopener noreferrer" target="_blank">爬虫入门到精通系统教程</a>第十讲</p><p>在之前我们讲解了如何爬取网页（不管是异步加载的还是普通的），但是爬取下来的数据该如何保存呢？</p><h2 id="保存到文本文件？"><a href="#保存到文本文件？" class="headerlink" title="保存到文本文件？"></a>保存到文本文件？</h2><p>可能有人会说那我保存在文本文件里面，这样也是可以的，但是到你需要用这个数据的时候，可能就会很麻烦了…</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3e7zp2qwj208z0bu0uj.jpg" alt=""><br>我今天爬取了10000部日本电影</p><p>假如说你要找苍老师出演的，那么你可能会说，我直接<code>ctrl+f</code>查找”苍老师”不就行了</p><p>但是假如你想要找”苍老师+无码”怎么办呢？？？</p><p>这个时候就是体现数据库的作用了。</p><h2 id="Mongodb的介绍"><a href="#Mongodb的介绍" class="headerlink" title="Mongodb的介绍"></a>Mongodb的介绍</h2><h3 id="为什么用mongodb呢？"><a href="#为什么用mongodb呢？" class="headerlink" title="为什么用mongodb呢？"></a>为什么用mongodb呢？</h3><ol><li>文档结构的存储方式</li><li>简单讲就是可以直接存json,list</li><li>不要事先定义”表”,随时可以创建</li><li>“表”中的数据长度可以不一样</li><li>也就是第一条记录有10个值，第二条记录不要规定也要10个值</li><li>对爬虫这种很乱的数据来说，很适用 。</li></ol><h2 id="Mongodb的安装"><a href="#Mongodb的安装" class="headerlink" title="Mongodb的安装"></a>Mongodb的安装</h2><p>直接到 <a href="https://www.mongodb.com/download-center#community" rel="external nofollow noopener noreferrer" target="_blank">https://www.mongodb.com/download-center#community</a>选择合适的版本下载安装就可以了。</p><p>安装完成后</p><p>windows用户在<br><code>bin</code>目录下新建一个<code>data</code>的文件夹<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1feoqdlmycmj20et0f9aaq.jpg" alt=""></p><p>然后在新建一个<code>start.bat</code>文件,内容写上<br><code>mongod --dbpath ./data</code><br>后面每次只要直接打开这个.bat 文件mongodb就运行了<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1feoqfgpnajj20mn0czq3i.jpg" alt=""><br>你可以直接选中<code>start.bat</code>，发送到桌面快捷方式，这样你以后可以直接在桌面打开了<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1feoqid02mpj20qq0ifabn.jpg" alt=""></p><h2 id="mongodb的基本使用"><a href="#mongodb的基本使用" class="headerlink" title="mongodb的基本使用"></a>mongodb的基本使用</h2><p>首先 <code>pip install pymongo</code></p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1feoqkudq2zj20jb0bvq33.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1feoqlm5lokj20rv0jg3yy.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1feoqm6dds3j20rp0agwen.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1feoqnkyg24j20xv0idq3l.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1feoqnkv3jsj20ye0hxwez.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1feoqnkxqzij20ss0g374s.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1feoqnl1sjdj20wx0gngm9.jpg" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="爬虫经常用到的三条插入语句"><a href="#爬虫经常用到的三条插入语句" class="headerlink" title="爬虫经常用到的三条插入语句"></a>爬虫经常用到的三条插入语句</h3><p>下面的<strong>test2为表名</strong>,</p><ul><li><code>test2.insert_one(xx)</code> 插入一条数据</li><li><code>test2.insert_many(xx)</code> 插入list</li><li><strong>最常用&gt;&gt;&gt;</strong><code>test2.update_one({&#39;x&#39;:1},{&#39;$set&#39;:{&#39;x&#39;:3}},upsert=True)</code></li><li>第三条一般会在防止重复的数据被存到数据库内 要用到</li></ul><p>代码都在 <a href="https://github.com/kimg1234/pachong/blob/master/mongodb%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.ipynb" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/kimg1234/pachong/blob/master/mongodb%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.ipynb</a></p><p>参考文档</p><ul><li><a href="http://www.runoob.com/mongodb/mongodb-tutorial.html" rel="external nofollow noopener noreferrer" target="_blank">mongodb中文文档</a></li><li><a href="https://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.find_one_and_update" rel="external nofollow noopener noreferrer" target="_blank">mongodb官方文档</a></li></ul><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      本文章属于爬虫入门到精通系统教程第十讲

在之前我们讲解了如何爬取网页（不管是异步加载的还是普通的），但是爬取下来的数据该如何保存呢？

保存到文本文件？
可能有人会说那我保存在文本文件里面，这样也是可以的，但是到你需要用这个数据的时候，可能就会很麻烦了…


我今天爬取了10000部日本电影

假如说你要找苍老师出演的，那么你可能会说，我直接ctrl+f查找”苍老师”不就行了

但是假如你想要找”苍老师+无码”怎么办呢？？？

这个时候就是体现数据库的作用了。

Mongodb的介绍
为什么用mongodb呢？
 1. 文档结构的存储方式
 2. 简单讲就是可以直接存json,list
 3
    
    </summary>
    
      <category term="爬虫" scheme="https://jin10086.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="mongodb" scheme="https://jin10086.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>headers的详细讲解（If-modified-since）</title>
    <link href="https://jin10086.github.io/2018/02/03/headers%E7%9A%84%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3%EF%BC%88If-modified-since%EF%BC%89/"/>
    <id>https://jin10086.github.io/2018/02/03/headers的详细讲解（If-modified-since）/</id>
    <published>2018-02-03T09:30:25.000Z</published>
    <updated>2018-04-04T07:12:10.669Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲解的知识点是headers里面的If-modified-since</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>本次我们要抓取的内容是苹果应用商店里面的所有app <a href="https://itunes.apple.com/cn/genre/ios/id36" rel="external nofollow noopener noreferrer" target="_blank">从 iTunes 下载的 App Store</a><br>当我第一次打开<a href="https://itunes.apple.com/cn/app/%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80/id989673964" rel="external nofollow noopener noreferrer" target="_blank">王者荣耀：在 App Store</a> 上的内容网页的时候，再次刷新的时候，你会看到http状态码返回 304<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3e36k8vrj210q0id49d.jpg" alt=""></p><p>那么知道了这个http状态码304对我们爬虫有什么用呢？</p><p>当我需要每天的爬取苹果应用商店的app的时候，因为苹果app很多，所以每次如果我全部爬取的话，会花费很多的时间，其实我只要抓取有更新的内容就好了。那么http状态码304就派上用场了。</p><h2 id="看代码"><a href="#看代码" class="headerlink" title="看代码"></a>看代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">headers = &#123;<span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36'</span>&#125;</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://itunes.apple.com/cn/app/%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80/id989673964'</span></span><br><span class="line"></span><br><span class="line">z = requests.get(url,headers=headers)</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3e3xshabj20yf07hwil.jpg" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取上次修改时间</span></span><br><span class="line">last_modified = z.headers[<span class="string">'Last-Modified'</span>]</span><br><span class="line"><span class="comment"># 修改headers</span></span><br><span class="line">headers[<span class="string">'If-Modified-Since'</span>] = last_modified</span><br></pre></td></tr></table></figure><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">z1 = requests.get(url,headers=headers)</span><br><span class="line"><span class="keyword">print</span> z1.status_code</span><br><span class="line"><span class="comment"># 304</span></span><br><span class="line"><span class="comment"># 可以看到已经返回状态码304，表示网页没有更新</span></span><br></pre></td></tr></table></figure><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">z2 = requests.head(url,headers=headers)</span><br><span class="line"><span class="keyword">if</span> z1.headers[<span class="string">'Last-Modified'</span>] == last_modified:</span><br><span class="line"><span class="keyword">print</span> <span class="string">u'网页没有更新'</span></span><br><span class="line"><span class="comment"># 这种方法也可以知道网页是否有更新</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>那么假如我要每天爬取苹果应该商店的app，那么我会在第一次请求的时候吧每个网页的上次修改时间存到数据库（也就是If-Modified-Since）</p><p>然后在我第二次爬取的时候，我会把上次存到数据库的时间放到headers里面，如果http状态码返回304,则表示网页没有更新，我可以不用再次解析网页，这样会节约大量时间…</p><p>最后代码在 <a href="https://github.com/jin10086/pachong/blob/master/If-modified-since.ipynb" rel="external nofollow noopener noreferrer" target="_blank">kimg1234/pachong</a></p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      本文讲解的知识点是headers里面的If-modified-since

案例
本次我们要抓取的内容是苹果应用商店里面的所有app 从 iTunes 下载的 App Store
当我第一次打开王者荣耀：在 App Store 上的内容网页的时候，再次刷新的时候，你会看到http状态码返回 304


那么知道了这个http状态码304对我们爬虫有什么用呢？

当我需要每天的爬取苹果应用商店的app的时候，因为苹果app很多，所以每次如果我全部爬取的话，会花费很多的时间，其实我只要抓取有更新的内容就好了。那么http状态码304就派上用场了。

看代码
1
2
3
4
5
6
7


impo
    
    </summary>
    
      <category term="爬虫" scheme="https://jin10086.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="headers" scheme="https://jin10086.github.io/tags/headers/"/>
    
      <category term="If-modified-since" scheme="https://jin10086.github.io/tags/If-modified-since/"/>
    
  </entry>
  
</feed>
