<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>高金的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jin10086.github.io/"/>
  <updated>2018-06-13T17:04:00.316Z</updated>
  <id>https://jin10086.github.io/</id>
  
  <author>
    <name>Gao JIn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>EOS hackathon 香港总结</title>
    <link href="https://jin10086.github.io/2018/06/14/EOS-hackathon-%E9%A6%99%E6%B8%AF%E6%80%BB%E7%BB%93/"/>
    <id>https://jin10086.github.io/2018/06/14/EOS-hackathon-香港总结/</id>
    <published>2018-06-13T16:29:03.000Z</published>
    <updated>2018-06-13T17:04:00.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>上周末去参加了EOS在香港举行的黑客松…</p><p>第一次去香港,发现香港住的地方真小…物价好贵…麦当劳都吃不起…</p><h2 id="选题"><a href="#选题" class="headerlink" title="选题"></a>选题</h2><p>因为本次黑客松是自己选题的，所以很早就一直在想要做什么…</p><p>个人参加过很多次黑客松的经验来看，觉得一个好的想法,就成功了一半呢!</p><h3 id="想法的由来"><a href="#想法的由来" class="headerlink" title="想法的由来"></a>想法的由来</h3><p>在飞机上 看书的时候[增长黑客],有看到 关于定位的，大概是一个利用定于做的小游戏，就突然想到…本次黑客松我们也可以基于定位来做，可以说叫做 线上与线下的结合，让区块链结合现实来做一些东西，感觉还是蛮好玩的…</p><h3 id="确定项目"><a href="#确定项目" class="headerlink" title="确定项目"></a>确定项目</h3><p>吧项目和小岛说了后，觉得还可以…刚好上周在薅星云的羊毛，然后发现了一款星云上面的红包dapp，用的人还是蛮多的。就准备做基于 LBS的红包</p><p>当然（我们还有另外几个选题，大家讨论后被reject了…)</p><h3 id="产品功能"><a href="#产品功能" class="headerlink" title="产品功能"></a>产品功能</h3><p>确定做后，我们大概整理了下需要实现的功能</p><ol><li>最基础的版本 &gt;&gt;&gt; 发红包后，生成指定链接，然后点开链接就能抢</li><li>在1上面扩展，可以指定坐标，必须要在坐标多少米内，才能领取这个红包</li><li>在2上面扩展，可以指定红包开始抢的时间（必须要在指定时间后才可以抢）</li><li>附加功能，可以指定白名单内的用户才能抢</li></ol><h3 id="产品的使用场景"><a href="#产品的使用场景" class="headerlink" title="产品的使用场景"></a>产品的使用场景</h3><ol><li>普通红包就不用说了</li><li>2+4 可以诱导某人必须出去活动，比如说 我想要让我儿子不那么宅，我就可以给他发一个白名单红包，并且把地点设置在某个地方（如中山公园），那么他想要抢到这个红包，必须到中山公园去…</li><li>2+3+4 可以做为广告来用，如 我肯德基可以做一个预售，明天10点，在我店附近可以领到我们发的红包…</li></ol><h2 id="coding"><a href="#coding" class="headerlink" title="coding"></a>coding</h2><p>因为我是c++（基本上不会）<br>所以，所有的代码都是小岛写的<br>我就负责测试环境这类的(打杂)</p><p>coding中发现的一些问题</p><p>一个最大的坑是</p><p>假如合约要给你打钱，也就是送币…<br>发现一直赠送不成功，显示没有授权…<br>查文档搜索都没有找到怎么做…</p><p>然后问了现场的人指导老师，终于才搞定了…（原来这个代码刚改的，文档还没有写，所以找不到！！！</p><p>解法是，需要你授权给我合约…（很奇怪的逻辑…我给你送钱，还需要你授权给我合约，这样我才能送钱给你。。。）</p><p>但是我们试了下还是有点问题…弄了半天，当时都快要崩溃了…最后试出来了…</p><p>解法是 <strong>合约给合约自己授权</strong> 感觉很无语…（感觉来黑客松就是给EOS做测试来的…</p><h2 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h2><p>最后，我们实现了上面我们列出的功能，然后竟然前10都没有进…</p><p>反正很不开心,毕竟努力了…</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>失败了，总需要想想为啥会失败，后续才会做的更好…</p><p>我认为我们的dapp还是挺好玩的,应该能吸引到人。不过老外没有发红包的习惯，所以会不会他觉得是很好玩，但是感觉没什么用。。。（文化差异…</p><p>进前10 的很多产品基本上 和EOS的生态有关，所以 参加的时候，应该想想<strong>主办方为啥想组织这个活动</strong></p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fsa1oj03kkj21400u0b2a.jpg" alt="上一张合照"></p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      背景
上周末去参加了EOS在香港举行的黑客松…

第一次去香港,发现香港住的地方真小…物价好贵…麦当劳都吃不起…

选题
因为本次黑客松是自己选题的，所以很早就一直在想要做什么…

个人参加过很多次黑客松的经验来看，觉得一个好的想法,就成功了一半呢!

想法的由来
在飞机上 看书的时候[增长黑客],有看到 关于定位的，大概是一个利用定于做的小游戏，就突然想到…本次黑客松我们也可以基于定位来做，可以说叫做 线上与线下的结合，让区块链结合现实来做一些东西，感觉还是蛮好玩的…

确定项目
吧项目和小岛说了后，觉得还可以…刚好上周在薅星云的羊毛，然后发现了一款星云上面的红包dapp，用的人还是蛮多的。
    
    </summary>
    
      <category term="hackathon" scheme="https://jin10086.github.io/categories/hackathon/"/>
    
    
  </entry>
  
  <entry>
    <title>2018学习计划</title>
    <link href="https://jin10086.github.io/2018/06/14/2018%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <id>https://jin10086.github.io/2018/06/14/2018学习计划/</id>
    <published>2018-06-13T16:23:05.000Z</published>
    <updated>2018-06-13T16:28:49.986Z</updated>
    
    <content type="html"><![CDATA[<p>最近发现自己大概半年没有什么进步,也不知道自己在干嘛…</p><p>上周末去香港EOS hackathon的时候，发现了自己的几个问题…</p><ul><li>英语太差,感觉完全没法交流啊…</li><li>太弱了…</li></ul><p>给自己定下个小目标</p><p>每个月看一本书，并写下读书笔记<br>每天最少背10个单次</p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      最近发现自己大概半年没有什么进步,也不知道自己在干嘛…

上周末去香港EOS hackathon的时候，发现了自己的几个问题…

 * 英语太差,感觉完全没法交流啊…
 * 太弱了…

给自己定下个小目标

每个月看一本书，并写下读书笔记
每天最少背10个单次
    
    </summary>
    
      <category term="学习计划" scheme="https://jin10086.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>一行代码损失了？？？RMB</title>
    <link href="https://jin10086.github.io/2018/05/24/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%8D%9F%E5%A4%B1%E4%BA%86%EF%BC%9F%EF%BC%9F%EF%BC%9FRMB/"/>
    <id>https://jin10086.github.io/2018/05/24/一行代码损失了？？？RMB/</id>
    <published>2018-05-24T06:50:38.000Z</published>
    <updated>2018-05-24T06:55:00.833Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>又发现一个ERC20 超级大的漏洞</p><p>这个漏洞严重到什么情况呢？</p><p><strong>你的钱不再是你的钱，任何人都可以把你的钱转走，你也可以转走任何人的钱</strong></p><p>那笔操作记录是 <a href="https://etherscan.io/tx/0x9a6a0ba68214db82ec6fd12ee3a6b4cf1143ec963974d7a5edf97e08b6c482ca" rel="external nofollow noopener noreferrer" target="_blank">0x9a6a0ba68214db82ec6fd12ee3a6b4cf1143ec963974d7a5edf97e08b6c482ca</a></p><p><img src="https://s1.ax1x.com/2018/05/24/CW30Qf.png" alt="CW30Qf.png"><br>下面我来带大家看看，黑客是如何实现的！</p><p>我们可以看到执行的方法是 <code>transferFrom</code></p><p>那这个方法是干嘛的呢？（从某个人 转钱到 另外一个人 ）</p><p>这个方法有一个配套的方法<code>approve</code>，你授权某个人用多少你的钱。。。</p><p>所以，这两个方法的使用场景是，</p><p>举个例子：</p><p>我授权我儿子使用我的100块钱，那我先调用<code>approve</code><br>然后 我儿子要用钱的时候，调用<code>transferFrom</code>来用我的钱，当然用一次少一次（而且每次用的钱不能超过我授权的钱）</p><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) &#123;</span><br><span class="line">    /// same as above</span><br><span class="line">    require(_to != 0x0);</span><br><span class="line">    require(balances[_from] &gt;= _value);</span><br><span class="line">    require(balances[_to] + _value &gt; balances[_to]);</span><br><span class="line"></span><br><span class="line">    uint previousBalances = balances[_from] + balances[_to];</span><br><span class="line">    balances[_from] -= _value;</span><br><span class="line">    balances[_to] += _value;</span><br><span class="line">    allowed[_from][msg.sender] -= _value;</span><br><span class="line">    Transfer(_from, _to, _value);</span><br><span class="line">    assert(balances[_from] + balances[_to] == previousBalances);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法会传入三个参数</p><ol><li>_from :在用谁的钱</li><li>_to : 把钱给谁</li><li>_value : 准备用多少钱</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require(_to != 0x0);</span><br><span class="line">require(balances[_from] &gt;= _value);</span><br><span class="line">require(balances[_to] + _value &gt; balances[_to]);</span><br></pre></td></tr></table></figure><p>这三行是一些强制要求</p><ol><li>你不能把钱转给0x0,也就是空地址</li><li>你在用谁的钱（那么这个人的余额一定要大于 你要用的钱）</li><li>你转给的那个人钱，那么那个人的余额一定要大于 之前的余额（也就是不能转个-1之类的，导致他余额反而变少了）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint previousBalances = balances[_from] + balances[_to];</span><br><span class="line">balances[_from] -= _value;</span><br><span class="line">balances[_to] += _value;</span><br></pre></td></tr></table></figure><p>这三行</p><ol><li>算出两个人余额的总数</li><li>from 那个人的余额 - value</li><li>to 那个人的余额 + value</li></ol><p><code>allowed[_from][msg.sender] -= _value;</code></p><p>这一行我们分解下<br><code>allowed[_from][msg.sender]</code> 是 当前方法调用的人（msg.sender）可以使用(_from) 多少钱</p><p>也就是假如 我授权了我儿子100块，那么 </p><p>allowed[我的地址][msg.sender] = 100(这边的msg.sender 需要是我儿子的地址，如果是别人的话，我没有授权给他，则是0 </p><p>所以这一行原本的意思是 (我儿子用了多少授权的金额，那么总授权金额需要 减掉 被用掉的）</p><p>但是呢。。。因为没用用safemath…导致任何人都能通过这一行（也就是 0- value)</p><p>0-value是不会报错的（当然如果用safemath的话，是会报错的。。。）</p><p>所以呢，只要你找到一个有钱人的地址，，，然后就可以吧他的钱全部转给任何账户。。。</p><p>下面的代码就没有意义了，不需要解释了。。。</p><p>而且他这个合约 没有暂停的方法。。。</p><p>导致现在任何人都可以调用这个合约。。。</p><h2 id="合约的问题"><a href="#合约的问题" class="headerlink" title="合约的问题"></a>合约的问题</h2><ol><li>当然是做加减乘除的时候没有用safemath</li><li>逻辑还有一个问题</li></ol><p>正常来说，应该需要加一个 判断，被授权的金额 不能大于 要发送的金额。。。</p><p><code>require(allowed[_from][msg.sender] &gt;= _value);</code></p><p>这样的话 后面也就不会有这些事情了。。。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我发现了 攻击这个合约的人 已经攻击了很多合约了！！！<br><img src="https://s1.ax1x.com/2018/05/24/CW3By8.png" alt="CW3By8.png"><br>这一些币大家就别抄底了!</p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      背景
又发现一个ERC20 超级大的漏洞

这个漏洞严重到什么情况呢？

你的钱不再是你的钱，任何人都可以把你的钱转走，你也可以转走任何人的钱

那笔操作记录是 0x9a6a0ba68214db82ec6fd12ee3a6b4cf1143ec963974d7a5edf97e08b6c482ca


下面我来带大家看看，黑客是如何实现的！

我们可以看到执行的方法是 transferFrom

那这个方法是干嘛的呢？（从某个人 转钱到 另外一个人 ）

这个方法有一个配套的方法approve，你授权某个人用多少你的钱。。。

所以，这两个方法的使用场景是，

举个例子：

我授权我儿子使用我的1
    
    </summary>
    
      <category term="区块链" scheme="https://jin10086.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>如何用myetherwallet 来玩智能合约</title>
    <link href="https://jin10086.github.io/2018/04/26/%E5%A6%82%E4%BD%95%E7%94%A8myetherwallet-%E6%9D%A5%E7%8E%A9%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    <id>https://jin10086.github.io/2018/04/26/如何用myetherwallet-来玩智能合约/</id>
    <published>2018-04-26T12:05:47.000Z</published>
    <updated>2018-04-26T12:06:39.338Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何用myetherwallet-来玩智能合约"><a href="#如何用myetherwallet-来玩智能合约" class="headerlink" title="如何用myetherwallet 来玩智能合约"></a>如何用myetherwallet 来玩智能合约</h2><p>用myetherwallet之前，请先看看 <a href="https://zhuanlan.zhihu.com/p/36105871" rel="external nofollow noopener noreferrer" target="_blank">黑客已经盗了15,945,221.72 USD</a></p><p>看完应该会知道如何安全的使用 myetherwallet 了.</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p><strong>本次我们玩的合约是 <a href="https://ropsten.etherscan.io/address/0x39171828d0c6d072c19f5d32900e30343c296f38" rel="external nofollow noopener noreferrer" target="_blank">https://ropsten.etherscan.io/address/0x39171828d0c6d072c19f5d32900e30343c296f38</a></strong></p><h3 id="确定合约是在哪个网"><a href="#确定合约是在哪个网" class="headerlink" title="确定合约是在哪个网"></a>确定合约是在哪个网</h3><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqpucquu3ij20fe0b83zv.jpg" alt=""></p><p>以上就是常见的所有网了</p><p>如果网址 前缀是ropsten，那么就是 ropsten测试网…</p><p>如果网址 前缀是kovan，那么就是 kovan测试网…</p><p>网址前面没有带的，如<a href="https://etherscan.io/address/0x39171828d0c6d072c19f5d32900e30343c296f38" rel="external nofollow noopener noreferrer" target="_blank">https://etherscan.io/address/0x39171828d0c6d072c19f5d32900e30343c296f38</a></p><p>这种就是主网…</p><p>除了主网外，其他的网都是测试网（也就是获取ETH是免费的）</p><p>我们本次测试的时候，网址是<a href="https://ropsten.etherscan.io/address/0x39171828d0c6d072c19f5d32900e30343c296f38" rel="external nofollow noopener noreferrer" target="_blank">https://ropsten.etherscan.io/address/0x39171828d0c6d072c19f5d32900e30343c296f38</a></p><p>那么我们本次玩的合约在 ropsten.</p><h3 id="获取合约地址"><a href="#获取合约地址" class="headerlink" title="获取合约地址"></a>获取合约地址</h3><p>合约地址还是很简单就能知道的</p><p>如本次我们要玩的网址是<a href="https://ropsten.etherscan.io/address/**0x39171828d0c6d072c19f5d32900e30343c296f38*" rel="external nofollow noopener noreferrer" target="_blank">https://ropsten.etherscan.io/address/**0x39171828d0c6d072c19f5d32900e30343c296f38*</a>*</p><p>那么合约地址就是 <strong>0x39171828d0c6d072c19f5d32900e30343c296f38</strong></p><h3 id="获取ABI"><a href="#获取ABI" class="headerlink" title="获取ABI"></a>获取ABI</h3><p>打开<a href="https://ropsten.etherscan.io/address/0x39171828d0c6d072c19f5d32900e30343c296f38#code" rel="external nofollow noopener noreferrer" target="_blank">https://ropsten.etherscan.io/address/0x39171828d0c6d072c19f5d32900e30343c296f38#code</a> (注意，如果你要玩的合约地址，不一样的话，则可以吧address 后面的地址替换成你的…)</p><p>复制contract ABI 里面的内容…(这就是ABI)</p><p>如果打开没有的话，则说明这个合约没有开源…</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqpup111sfj222k14uqja.jpg" alt=""></p><h3 id="打开myetherwallet"><a href="#打开myetherwallet" class="headerlink" title="打开myetherwallet"></a>打开myetherwallet</h3><ul><li><p>打开 <a href="https://www.myetherwallet.com/#contracts" rel="external nofollow noopener noreferrer" target="_blank">https://www.myetherwallet.com/#contracts</a></p></li><li><p>选择正确的网</p></li></ul><p>可以看到，每个都有好几个，随便选择一个就行…(本次我们是ropsten，也就是只要前面是ropsten的，你随便选哪个都可以）</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqput51107j20z80zkqa1.jpg" alt=""></p><ul><li>复制上你合约地址 与 合约ABI ，然后点击Access</li></ul><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqpuwhj65ij225o0n2wk1.jpg" alt=""></p><ul><li>选则你要调用的方法</li></ul><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqpuxrptpaj212810iq6n.jpg" alt=""></p><p>（本次我们选择 <code>batchTransfer</code>)</p><ul><li>输入你的参数</li></ul><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqpvf9kw43j21p20taq79.jpg" alt=""></p><p>本次我们的参数 如上图所示…<br>不知道为啥 请看<a href="https://mp.weixin.qq.com/s?__biz=MzU2OTAxNTcwMw==&amp;mid=2247483863&amp;idx=1&amp;sn=5029734091080c37923f9bd666a6e1fa&amp;chksm=fc846d2fcbf3e439e4f25ad1c7915c10ee8b375f791a260e0cd273d982aa521948d325f59121#rd" rel="external nofollow noopener noreferrer" target="_blank">一行代码蒸发了¥6,447,277,680 人民币！</a></p><ul><li>连接到metamask（metamask 没有装的话，请百度.)</li></ul><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqpv39fzkuj223s0uqtg7.jpg" alt=""></p><ul><li>点击write </li></ul><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqpvh38jhmj21840rwad6.jpg" alt=""></p><p>注意，gaslimit 会自动出来…如果gas limit 那边为空的话，请确认你的参数…</p><ul><li>点击生成交易</li></ul><p>确认提交就可以了</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqpviza1z9j215u12awk3.jpg" alt=""></p><ul><li>然后这笔交易会发送到metamask上，点击submit 就可以了.<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqpvkhkfb8j20ke0qmgoh.jpg" alt=""></li></ul><p>我本次提交成功后的 tx <a href="https://ropsten.etherscan.io/tx/0x8359cfe6c0ccbb9a8126531c1162e80fb0c6f0beecb10bdcd0843bc368848b33" rel="external nofollow noopener noreferrer" target="_blank">https://ropsten.etherscan.io/tx/0x8359cfe6c0ccbb9a8126531c1162e80fb0c6f0beecb10bdcd0843bc368848b33</a></p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      如何用myetherwallet 来玩智能合约
用myetherwallet之前，请先看看 黑客已经盗了15,945,221.72 USD

看完应该会知道如何安全的使用 myetherwallet 了.

开始
本次我们玩的合约是 https://ropsten.etherscan.io/address/0x39171828d0c6d072c19f5d32900e30343c296f38

确定合约是在哪个网


以上就是常见的所有网了

如果网址 前缀是ropsten，那么就是 ropsten测试网…

如果网址 前缀是kovan，那么就是 kovan测试网…

网址前面没有带的，如htt
    
    </summary>
    
      <category term="区块链" scheme="https://jin10086.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="myetherwallet" scheme="https://jin10086.github.io/tags/myetherwallet/"/>
    
      <category term="智能合约" scheme="https://jin10086.github.io/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>黑客已经盗了15,945,221.72 USD</title>
    <link href="https://jin10086.github.io/2018/04/25/%E9%BB%91%E5%AE%A2%E5%B7%B2%E7%BB%8F%E7%9B%97%E4%BA%8615-945-221-72-USD/"/>
    <id>https://jin10086.github.io/2018/04/25/黑客已经盗了15-945-221-72-USD/</id>
    <published>2018-04-25T08:03:11.000Z</published>
    <updated>2018-04-25T08:03:55.997Z</updated>
    
    <content type="html"><![CDATA[<h2 id="黑客已经盗了15-945-221-72-USD"><a href="#黑客已经盗了15-945-221-72-USD" class="headerlink" title="黑客已经盗了15,945,221.72 USD"></a>黑客已经盗了15,945,221.72 USD</h2><p>myetherwallet 昨日发推特说，他们的DNS 被污染，导致部分用户进入到了假的 网站，从而导致ETH被盗</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqox4nbpl4j20yy0lq0xl.jpg" alt=""></p><p>截止到今天（2018-04-25 15:00) 黑客已经累计盗取了24,130.543323767777777777 Ether</p><p>换算成美元大概 $15,945,221.72 (@ $660.79/ETH)</p><p>这还没有包括 $143,924.09 的代币</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqox8zeu82j20r40p0ju6.jpg" alt=""></p><p>本文发出的时候，黑客账号还持续进账！！！</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqox5i91o0j21xq18itqh.jpg" alt=""></p><p> <a href="https://etherscan.io/address/0xb3aaaae47070264f3595c5032ee94b620a583a39" rel="external nofollow noopener noreferrer" target="_blank">黑客的钱包地址</a></p><h2 id="一些网友在该账户下面的评论"><a href="#一些网友在该账户下面的评论" class="headerlink" title="一些网友在该账户下面的评论"></a>一些网友在该账户下面的评论</h2><p> <img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqoxb4i56hj21we0tugtm.jpg" alt=""></p><p> <img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqoxc5pb13j21we0ocwml.jpg" alt=""></p><p> 还有一些人在乘机诈骗<br> <img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqoxe3ykbpj21ww0emwil.jpg" alt=""></p><p> 还有一些很可怜的人…</p><p> <img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqoxejlpp1j215606iq46.jpg" alt=""></p><p> 更多评论在<a href="https://etherscan.io/address/0xb3aaaae47070264f3595c5032ee94b620a583a39#comments" rel="external nofollow noopener noreferrer" target="_blank">0xb3aaaae47070264f3595c5032ee94b620a583a39</a></p><h2 id="什么是DNS欺骗"><a href="#什么是DNS欺骗" class="headerlink" title="什么是DNS欺骗"></a>什么是DNS欺骗</h2><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><blockquote><p>举一个例子，zh.wikipedia.org作为一个域名就和IP地址208.80.154.225相对应。DNS就像是一个自动的电话号码簿，我们可以直接拨打wikipedia的名字来代替电话号码（IP地址）。DNS在我们直接调用网站的名字以后就会将像zh.wikipedia.org一样便于人类使用的名字转化成像208.80.154.225一样便于机器识别的IP地址。</p></blockquote><blockquote><p>DNS查询有两种方式：递归和迭代。DNS客户端设置使用的DNS服务器一般都是递归服务器，它负责全权处理客户端的DNS查询请求，直到返回最终结果。而DNS服务器之间一般采用迭代查询方式。</p></blockquote><blockquote><p>以查询zh.wikipedia.org为例：</p></blockquote><blockquote><p>客户端发送查询报文”query zh.wikipedia.org”至DNS服务器，DNS服务器首先检查自身缓存，如果存在记录则直接返回结果。<br>如果记录老化或不存在，则<br>DNS服务器向根域名服务器发送查询报文”query zh.wikipedia.org”，根域名服务器返回.org域的权威域名服务器地址，这一级首先会返回的是顶级域名的权威域名服务器。<br>DNS服务器向.org域的权威域名服务器发送查询报文”query zh.wikipedia.org”，得到.wikipedia.org域的权威域名服务器地址。<br>DNS服务器向.wikipedia.org域的权威域名服务器发送查询报文”query zh.wikipedia.org”，得到主机zh的A记录，存入自身缓存并返回给客户端。</p></blockquote><p>简单的讲 就是:</p><p>假如我今天要打开百度</p><ul><li>那我先在浏览器输入 <a href="https://www.baidu.com" rel="external nofollow noopener noreferrer" target="_blank">https://www.baidu.com</a></li><li>然后 首先会检查我本地的dns 缓存,看看知不知道 百度的 ip是多少,如果已经知道的话，则返回给我，那么最终我访问的是 这个ip（所以 在 <a href="https://www.baidu.com" rel="external nofollow noopener noreferrer" target="_blank">https://www.baidu.com</a> == 返回给我的ip </li><li>如果不知道的话，则继续问上一层dns服务器，直到问到为止！</li></ul><p>那么<strong>dns欺骗</strong>是咋回事呢？</p><p>假如我今天要打开百度<br>我问dns 服务器，百度的ip是多少(假如正确的是 115.239.210.27)<br>但是dns服务器告诉我，百度的ip是 192.168.2.221</p><p>那么我实际打开的也就是 192.168.2.221</p><p>而这台服务器也做了个和百度一模一样的页面，那么我是不知道我被骗了！！！</p><p>然后我再百度页 提交的任何东西，都被黑客知道了。。。</p><h3 id="本次事件"><a href="#本次事件" class="headerlink" title="本次事件"></a>本次事件</h3><p><img src="https://blog.cloudflare.com/content/images/2018/04/Slide1.png" alt=""></p><p><img src="https://blog.cloudflare.com/content/images/2018/04/Slide2.png" alt=""></p><p>已经有人画了两张图，很清楚的描述了具体情况</p><h2 id="那么我们如何避免这种情况呢？"><a href="#那么我们如何避免这种情况呢？" class="headerlink" title="那么我们如何避免这种情况呢？"></a>那么我们如何避免这种情况呢？</h2><ul><li><p>在<a href="https://www.myetherwallet.com" rel="external nofollow noopener noreferrer" target="_blank">https://www.myetherwallet.com</a> 上转账的时候，一定要确保域名 以及HTTPS证书是正确的！！！</p><p>  <strong>如下图，不是绿色的，一定不要在上面输入任何信息…</strong><br>  其实不管是任何网站，一定要看到颜色是绿色的！（表示证书被验证通过了）<br>  <img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqoy8u5c4mj20vc036758.jpg" alt=""></p><p>  如下这种情况，表示证书有问题（本次myetherwallet有弹出这个）<br>  如果你还点继续的话，那么只能说你 <strong>人傻钱多了</strong><br>  <img src="https://blog.cloudflare.com/content/images/2018/04/Screen-Shot-2018-04-24-at-1.55.12-PM.png" alt=""></p></li><li><p>在联网情况下，不要输入私钥！！！<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqoyioozdkj225e0rwdnn.jpg" alt=""></p></li></ul><p>要使用钱包的话，推荐使用metamask！！！</p><p>本次的话，如果你就算打开了钓鱼网站，只要你没有在网站上输入 私钥，而是用metamask的话，那么你的钱暂时还是安全的）</p><ul><li>如果一定要用私钥的话，一定要在断网环境!!!</li></ul><p><strong>最后，花上几分钟阅读 <a href="https://myetherwallet.github.io/knowledge-base/security/" rel="external nofollow noopener noreferrer" target="_blank">https://myetherwallet.github.io/knowledge-base/security/</a></strong></p><p><strong>如果是电脑小白的话，推荐使用硬体钱包！别在网上乱买！</strong></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.cloudflare.com/bgp-leaks-and-crypto-currencies/" rel="external nofollow noopener noreferrer" target="_blank">https://blog.cloudflare.com/bgp-leaks-and-crypto-currencies/</a><br><a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F" rel="external nofollow noopener noreferrer" target="_blank">https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F</a></p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      黑客已经盗了15,945,221.72 USD
myetherwallet 昨日发推特说，他们的DNS 被污染，导致部分用户进入到了假的 网站，从而导致ETH被盗



截止到今天（2018-04-25 15:00) 黑客已经累计盗取了24,130.543323767777777777 Ether

换算成美元大概 $15,945,221.72 (@ $660.79/ETH)

这还没有包括 $143,924.09 的代币



本文发出的时候，黑客账号还持续进账！！！



 黑客的钱包地址

一些网友在该账户下面的评论
 

 

 还有一些人在乘机诈骗


 还有一些很可怜的人…

 

    
    </summary>
    
      <category term="区块链" scheme="https://jin10086.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="myetherwallet" scheme="https://jin10086.github.io/tags/myetherwallet/"/>
    
      <category term="黑客" scheme="https://jin10086.github.io/tags/%E9%BB%91%E5%AE%A2/"/>
    
      <category term="安全" scheme="https://jin10086.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>一键上链</title>
    <link href="https://jin10086.github.io/2018/04/25/%E4%B8%80%E9%94%AE%E4%B8%8A%E9%93%BE/"/>
    <id>https://jin10086.github.io/2018/04/25/一键上链/</id>
    <published>2018-04-25T06:24:54.000Z</published>
    <updated>2018-04-26T06:56:46.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一键上链！"><a href="#一键上链！" class="headerlink" title="一键上链！"></a>一键上链！</h2><p>今天在朋友圈看到很多人在 讨论 <strong>北大yuexin上链</strong>事件.</p><p>虽然看到很多人写了教程 如何上链，但是觉得对普通人门槛还是太高了！</p><p>所以 做了一个一键上链的服务！</p><p>请直接点击&gt;&gt;&gt;<a href="http://www.dapdap.io/#/onChain" rel="external nofollow noopener noreferrer" target="_blank">一键上链</a></p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqo7ukywt7j20v00u07ij.jpg" alt=""></p><p>在文本框内输入你要上链的内容，然后点击提交即可！！！</p><p>成功后会看到如下内容，点击以太坊交易流水号.</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqo80hyhw8j21yq08wgn9.jpg" alt=""></p><p>页面拉到最下面，点击<em>convert to UTF8</em>，则可以在看到你上链的内容了！</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqomrevja2j21xm14y4bp.jpg" alt=""></p><p>如果还不明白的，我们做了一个动图！</p><p><img src="http://wx3.sinaimg.cn/mw690/cfc08357gy1fqq22c26a6g20bi0kg4nk.gif" alt=""></p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      一键上链！
今天在朋友圈看到很多人在 讨论 北大yuexin上链事件.

虽然看到很多人写了教程 如何上链，但是觉得对普通人门槛还是太高了！

所以 做了一个一键上链的服务！

请直接点击&gt;&gt;&gt;一键上链



在文本框内输入你要上链的内容，然后点击提交即可！！！

成功后会看到如下内容，点击以太坊交易流水号.



页面拉到最下面，点击convert to UTF8，则可以在看到你上链的内容了！



如果还不明白的，我们做了一个动图！
    
    </summary>
    
      <category term="区块链" scheme="https://jin10086.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="dapdap" scheme="https://jin10086.github.io/tags/dapdap/"/>
    
  </entry>
  
  <entry>
    <title>一行代码蒸发了¥6,447,277,680人民币！</title>
    <link href="https://jin10086.github.io/2018/04/22/%E4%BA%BA%E6%B0%91%E5%B8%81%EF%BC%81/"/>
    <id>https://jin10086.github.io/2018/04/22/人民币！/</id>
    <published>2018-04-22T15:24:05.000Z</published>
    <updated>2018-04-26T06:55:19.790Z</updated>
    
    <content type="html"><![CDATA[<p><strong>现在进入你还是先行者，最后观望者进场才是韭菜。</strong></p><p>美图董事长蔡文胜曾在三点钟群，高调的说出了这句话，随即被大众疯传。</p><p>在他发表完言论没多久，2月美链（BEC）上交易所会暴涨4000%，后又暴跌。尽管他多次否认，聪明的网友早已扒出，他与BEC千丝万缕的关系。</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqltga6j8bj20hs0dpqas.jpg" alt=""></p><p>庄家坐庄操控币价，美图的股价随之暴涨，蔡文胜顺利完成了他的韭菜收割大计。</p><p>但在币圈，割人者，人恒割之。</p><p>随着BEC智能合约的漏洞的爆出，被黑客利用，瞬间套现抛售大额BEC，6亿在瞬间归零。</p><p>而这一切，竟然是因为一个简单至极的程序Bug。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天有人在群里说，<a href="https://etherscan.io/address/0xc5d105e63711398af9bbff092d4b6769c82f793d" rel="external nofollow noopener noreferrer" target="_blank">Beauty Chain 美蜜</a> 代码里面有bug，已经有人利用该bug获得了  57,896,044,618,658,100,000,000,000,000,000,000,000,000,000,000,000,000,000,000.792003956564819968 个 BEC</p><p>那笔操作记录是 <a href="https://etherscan.io/tx/0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660f" rel="external nofollow noopener noreferrer" target="_blank">0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660f</a></p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqlpon57s4j21qe15c13c.jpg" alt=""></p><p>下面我来带大家看看，黑客是如何实现的！</p><p>我们可以看到执行的方法是 <code>batchTransfer</code></p><p>那这个方法是干嘛的呢？（给指定的几个地址，发送相同数量的代币）</p><h3 id="整体逻辑是"><a href="#整体逻辑是" class="headerlink" title="整体逻辑是"></a>整体逻辑是</h3><p>你传几个地址给我(_receivers),然后再传给我你要给每个人多少代币（_value)</p><p>然后你要发送的总金额 = 发送的人数* 发送的金额</p><p>然后 要求你当前的余额大于 发送的总金额</p><p>然后扣掉你发送的总金额</p><p>然后 给_receivers 里面的每个人发送 指定的金额（_value)</p><p>从逻辑上看，这边是没有任何问题的，你想给别人发送代币，那么你本身的余额一定要大于发送的总金额的！</p><p>但是这段代码却犯了一个很傻的错!</p><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqlpsliqg9j21aq0di41a.jpg" alt=""></p><p>这个方法会传入两个参数</p><ol><li>_receivers</li><li>_value</li></ol><p>_receivers 的值是个列表，里面有两个地址 </p><p><a href="https://etherscan.io/token/0xc5d105e63711398af9bbff092d4b6769c82f793d?a=0x0e823ffe018727585eaf5bc769fa80472f76c3d7" rel="external nofollow noopener noreferrer" target="_blank">0x0e823ffe018727585eaf5bc769fa80472f76c3d7</a></p><p><a href="https://etherscan.io/token/0xc5d105e63711398af9bbff092d4b6769c82f793d?a=0xb4d30cac5124b46c2df0cf3e3e1be05f42119033" rel="external nofollow noopener noreferrer" target="_blank">0xb4d30cac5124b46c2df0cf3e3e1be05f42119033</a></p><p>_value 的值是 <code>8000000000000000000000000000000000000000000000000000000000000000</code></p><p>我们再查看代码（如下图）</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqlpj1qxlxj226s0o8wjw.jpg" alt=""></p><p>我们一行一行的来解释</p><p><code>uint cnt = _receivers.length;</code></p><p>是获取 _receivers 里面有几个地址，我们从上面可以看到 参数里面只有两个地址，所以 cnt=2，也就是 给两个地址发送代币</p><p><code>uint256 amount = uint256(cnt) * _value;</code></p><h2 id="uint256"><a href="#uint256" class="headerlink" title="uint256"></a>uint256</h2><p>首先<code>uint256(cnt)</code> 是把cnt 转成了 uint256类型</p><p>那么,什么是uint256类型？或者说uint256类型的取值范围是多少…</p><p>uintx 类型的取值范围是 0 到 2的x次方 -1</p><p>也就是 假如是 uint8的话 </p><p>则 uint8的取值范围是 0 到 2的8次方 -1 </p><p>也就是 0 到255</p><p>那么uint256 的取值范围是 </p><p>0 - 2的256次方-1  也就是 <code>0 到115792089237316195423570985008687907853269984665640564039457584007913129639935</code></p><p>python 算 2的256次方是多少<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqlpjvwod1j20zs03c74x.jpg" alt=""></p><p>那么假如说 设置的值超过了 取值范围怎么办？这种情况称为<code>溢出</code></p><p>举个例子来说明</p><p>因为uint256的取值太大了，所以用uint8来 举例。。。</p><p>从上面我们已经知道了  uint8 最小是0，最大是255</p><p>那么当我 255 + 1 的时候，结果是啥呢？<strong>结果会变成0</strong></p><p>那么当我 255 + 2 的时候，结果是啥呢？<strong>结果会变成1</strong></p><p>那么当我 0 - 1  的时候，结果是啥呢？<strong>结果会变成255</strong></p><p>那么当我 0 - 2  的时候，结果是啥呢？<strong>结果会变成255</strong></p><p>那么 我们回到上面的代码中，</p><p><code>amount = uint256(cnt) * _value</code></p><p>则 amount = 2* _value</p><p>但是此时 _value 是16进制的，我们把他转成 10进制 </p><p>（python 16进制转10进制）<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqlqm9j1thj20y203sjs6.jpg" alt=""></p><p>可以看到 _value = <code>57896044618658097711785492504343953926634992332820282019728792003956564819968</code></p><p>那么amount = _value*2 = <code>115792089237316195423570985008687907853269984665640564039457584007913129639936</code></p><p>可以在查看上面看到 uint256取值范围最大为 <code>115792089237316195423570985008687907853269984665640564039457584007913129639935</code></p><p>此时，amout已经超过了最大值，溢出 则<code>amount = 0</code></p><p>下一行代码<br><code>require(cnt &gt; 0 &amp;&amp; cnt &lt;= 20);</code><br>require 语句是表示该语句一定要是正确的，也就是 cnt 必须大于0 且 小于等于20</p><p>我们的cnt等于2，通过!</p><p><code>require(_value &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount);</code></p><p>这句要求 _value 大于0，我们的_value是大于0 的<br>且,当前用户拥有的代币余额大于等于 amount,因为amount等于0，所以 就算你一个代币没有，也是满足的！</p><p><code>balances[msg.sender] = balances[msg.sender].sub(amount);</code></p><p>这句是当前用户的余额 - amount</p><p>当前amount 是0，所以当前用户代币的余额没有变动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (uint i = 0; i &lt; cnt; i++) &#123;</span><br><span class="line">    balances[_receivers[i]] = balances[_receivers[i]].add(_value);</span><br><span class="line">    Transfer(msg.sender, _receivers[i], _value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这句是遍历 _receivers中的地址，<br>对每个地址做以下操作</p><p><code>balances[_receivers[i]] = balances[_receivers[i]].add(_value);</code><br>_receivers中的地址 的余额 = 原本余额+value</p><p>所以 _receivers 中地址的余额 则加了57896044618658097711785492504343953926634992332820282019728792003956564819968 个代币！！！</p><p><code>Transfer(msg.sender, _receivers[i], _value);}</code><br>这句则只是把赠送代币的记录存下来！！！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>就一个简单的溢出漏洞，导致BEC代币的市值接近归0</p><p>那么，开发者有没有考虑到溢出问题呢？</p><p>其实他考虑了,</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqlssg2452j225m0o20y4.jpg" alt=""></p><p>可以看如上截图</p><p>除了amount的计算外, 其他的给用户转钱 都用了safeMath 的方法（sub,add)</p><p>那么 为啥就偏偏这一句没有用safeMath的方法呢。。。</p><p>这就要用写代码的人了。。。</p><h2 id="啥是safeMath"><a href="#啥是safeMath" class="headerlink" title="啥是safeMath"></a>啥是safeMath</h2><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqlsweul1oj21o014k105.jpg" alt=""></p><p>safeMath 是为了计算安全 而写的一个library</p><p>我们看看他干了啥？为啥能保证计算安全.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function mul(uint256 a, uint256 b) internal constant returns (uint256) &#123;</span><br><span class="line">uint256 c = a * b;</span><br><span class="line">assert(a == 0 || c / a == b);</span><br><span class="line">return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面的乘法.<br>他在计算后，用assert 验证了下结果是否正确！</p><p>如果在上面计算 amount的时候，用了 mul的话，<br>则 <code>c / a == b</code><br>也就是 验证 amount / cnt == _value </p><p>这句会执行报错的，因为 0 / cnt  不等于 _value</p><p>所以程序会报错！</p><p>也就不会发生溢出了…</p><p>那么 还有一个小问题，这里的<code>assert</code> 好 <code>require</code> 好像是干的同一件事</p><p>都是为了验证 某条语句是否正确！</p><p>那么他俩有啥区别呢？</p><p> 用了assert的话，则程序的gas limit 会消耗完毕</p><p>而require的话，则只是消耗掉当前执行的gas </p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>那么 我们如何避免这种问题呢？</p><p>我个人看法是</p><ol><li>只要涉及到计算，一定要用safeMath</li><li>代码一定要测试！</li><li>代码一定要review！</li><li>必要时，要请专门做代码审计的公司来 测试代码</li></ol><p>这件事后需要如何处理呢？</p><p>目前，该方法已经暂停了（还好可以暂停）所以看过文章的朋友 不要去测试了…</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fqltbqvtz7j227o0pyq8i.jpg" alt=""></p><p>不过已经发生了的事情咋办呢？</p><p>我的想法是，快照在漏洞之前，所有用户的余额情况</p><p>然后发行新的token，给之前的用户 发送等额的代币…</p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      现在进入你还是先行者，最后观望者进场才是韭菜。

美图董事长蔡文胜曾在三点钟群，高调的说出了这句话，随即被大众疯传。

在他发表完言论没多久，2月美链（BEC）上交易所会暴涨4000%，后又暴跌。尽管他多次否认，聪明的网友早已扒出，他与BEC千丝万缕的关系。



庄家坐庄操控币价，美图的股价随之暴涨，蔡文胜顺利完成了他的韭菜收割大计。

但在币圈，割人者，人恒割之。

随着BEC智能合约的漏洞的爆出，被黑客利用，瞬间套现抛售大额BEC，6亿在瞬间归零。

而这一切，竟然是因为一个简单至极的程序Bug。

背景
今天有人在群里说，Beauty Chain 美蜜 代码里面有bug，已经有人利用该
    
    </summary>
    
    
      <category term="区块链" scheme="https://jin10086.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>爬虫带你发现区块链好游戏</title>
    <link href="https://jin10086.github.io/2018/03/22/%E5%B8%A6%E4%BD%A0%E5%8F%91%E7%8E%B0%E5%A5%BD%E6%B8%B8%E6%88%8F/"/>
    <id>https://jin10086.github.io/2018/03/22/带你发现好游戏/</id>
    <published>2018-03-22T10:38:43.000Z</published>
    <updated>2018-04-04T07:12:10.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为啥做这个"><a href="#为啥做这个" class="headerlink" title="为啥做这个?"></a>为啥做这个?</h2><p><a href="https://zhuanlan.zhihu.com/p/34356844" rel="external nofollow noopener noreferrer" target="_blank">花了600万玩区块链游戏，我觉得智能合约还是有点靠谱的</a></p><p>要从这篇文章说起，之前帮nick拿数据的时候，就在想。既然 eth的所有数据都是公开的，那我是不是可以把所有的链上游戏的交易数据都拿下来，然后看看，</p><h3 id="针对所有游戏来说"><a href="#针对所有游戏来说" class="headerlink" title="针对所有游戏来说"></a>针对所有游戏来说</h3><ul><li>有多少人玩了区块链游戏？</li><li>有多少人赚了钱？</li><li>有多少人亏了钱？</li></ul><h3 id="针对某款游戏来说"><a href="#针对某款游戏来说" class="headerlink" title="针对某款游戏来说"></a>针对某款游戏来说</h3><p>有多少人玩过？<br>每天的日活是多少？<br>有多少人赚了钱？<br>有多少人亏了钱？</p><p>通过这些数据，那么我也就能分析出来</p><h1 id="这款游戏我现在玩能赚到钱么？"><a href="#这款游戏我现在玩能赚到钱么？" class="headerlink" title="这款游戏我现在玩能赚到钱么？"></a>这款游戏我现在玩能赚到钱么？</h1><h1 id="哪些游戏可能有猫腻？"><a href="#哪些游戏可能有猫腻？" class="headerlink" title="哪些游戏可能有猫腻？"></a>哪些游戏可能有猫腻？</h1><h1 id="哪些游戏一玩就亏钱？"><a href="#哪些游戏一玩就亏钱？" class="headerlink" title="哪些游戏一玩就亏钱？"></a>哪些游戏一玩就亏钱？</h1><h1 id="甚至还可以跟踪大佬（也就是赚钱最多的人"><a href="#甚至还可以跟踪大佬（也就是赚钱最多的人" class="headerlink" title="甚至还可以跟踪大佬（也就是赚钱最多的人)"></a>甚至还可以跟踪大佬（也就是赚钱最多的人)</h1><p>看看他在玩什么.</p><p>这样我们就可以愉快的”玩游戏”了</p><h2 id="Just-do-it"><a href="#Just-do-it" class="headerlink" title="Just do it!"></a>Just do it!</h2><p>有想法以后，一直想着赶快做出来…<br>然而我是个前端渣渣…<br>到哪里去找人一起来做呢？？？</p><p>刚好看到dorahack在西安举行hackthon.<br>就赶过去了，找到了一帮小伙伴一起把他完成了！</p><h2 id="网站演示"><a href="#网站演示" class="headerlink" title="网站演示"></a>网站演示</h2><p>网址在这&gt;&gt;&gt;<a href="http://www.dapdap.io/#/" rel="external nofollow noopener noreferrer" target="_blank">dapdap</a></p><p>查看所有dapp的情况<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fplswqo4awj211y0hpmz7.jpg" alt=""></p><p>查看某个游戏的收益情况<br><img src="http://ww1.sinaimg.cn/large/cfc08357ly1fplsy6022yj211y0hp75p.jpg" alt=""></p><p>查看某个游戏的收益情况（这是我的…<br><img src="http://ww1.sinaimg.cn/large/cfc08357ly1fplsz2rifyj211y0hpwfw.jpg" alt=""></p><p>某个游戏的用户情况<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fplt44ot0gj20uw0g7gmo.jpg" alt=""></p><h2 id="反馈与交流"><a href="#反馈与交流" class="headerlink" title="反馈与交流"></a>反馈与交流</h2><p>对这个网站有任何建议与吐槽的，欢迎加群！<br>想一起来玩区块链游戏的，欢迎加群讨论！<br>加群请扫描下面二维码<br>或者搜索718944415，加入！<br><img src="http://ww1.sinaimg.cn/large/cfc08357ly1fpltwfteelj206c07n0tf.jpg" alt=""><br>最后，网址是，<a href="http://www.dapdap.io" rel="external nofollow noopener noreferrer" target="_blank">http://www.dapdap.io</a></p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      为啥做这个?
花了600万玩区块链游戏，我觉得智能合约还是有点靠谱的

要从这篇文章说起，之前帮nick拿数据的时候，就在想。既然 eth的所有数据都是公开的，那我是不是可以把所有的链上游戏的交易数据都拿下来，然后看看，

针对所有游戏来说
 * 有多少人玩了区块链游戏？
 * 有多少人赚了钱？
 * 有多少人亏了钱？

针对某款游戏来说
有多少人玩过？
每天的日活是多少？
有多少人赚了钱？
有多少人亏了钱？

通过这些数据，那么我也就能分析出来

这款游戏我现在玩能赚到钱么？
哪些游戏可能有猫腻？
哪些游戏一玩就亏钱？
甚至还可以跟踪大佬（也就是赚钱最多的人)
看看他在玩什么.

这样我们就
    
    </summary>
    
      <category term="dapp" scheme="https://jin10086.github.io/categories/dapp/"/>
    
    
      <category term="以太坊" scheme="https://jin10086.github.io/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="dapdap.io" scheme="https://jin10086.github.io/tags/dapdap-io/"/>
    
  </entry>
  
  <entry>
    <title>知乎看图插件</title>
    <link href="https://jin10086.github.io/2018/03/06/%E7%9F%A5%E4%B9%8E%E7%9C%8B%E5%9B%BE%E6%8F%92%E4%BB%B6/"/>
    <id>https://jin10086.github.io/2018/03/06/知乎看图插件/</id>
    <published>2018-03-06T15:59:48.000Z</published>
    <updated>2018-04-04T07:12:10.673Z</updated>
    
    <content type="html"><![CDATA[<p>这个是受路人甲 之前发的一个插件的影响</p><p>我下载下来了 发现 竟然用不了。。。</p><p>而且只支持问题页看图</p><p>所以就修改了下。。。</p><p>而且开源放到了github上，主要是希望大家能一起维护他</p><p>毕竟靠一个人来做的话，是比较难的。。。</p><p>而且我比较懒。。。</p><p>我是个js菜鸟，代码有啥不忍直视的地方。。。</p><p>请随便喷。。。</p><h2 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h2><ol><li><p>把项目下载到本地</p></li><li><p>在chrome浏览器的地址栏输入 <code>chrome://extensions/</code></p></li><li>点击加载已解压的扩展程序</li><li>找到刚才下载的目录</li><li>如图所示，你就可以愉快的看图了<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fp3edo75urj20mb05g3yr.jpg" alt=""></li></ol><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p><code>Ctrl + Alt + D</code>开始运行插件<br><code>Ctrl + Alt + F</code>开始看图模式<br>方向键盘左键向左查看，右键向右查看<br>Esc退出看图模式</p><p>目前支持知乎上所有的页面的看图(如有不支持的，欢迎提issue)</p><p>项目地址在<a href="https://github.com/jin10086/zhihukantu" rel="external nofollow noopener noreferrer" target="_blank">知乎看图</a></p><h2 id="功能演示"><a href="#功能演示" class="headerlink" title="功能演示"></a>功能演示</h2><p>就是打开 你想看图的页面，然后输入Ctrl + Alt + D<br>再输入Ctrl + Alt + F 就可以愉快的看图了…</p><p><img src="http://wx1.sinaimg.cn/mw690/cfc08357gy1fp45ejqpryg20dc07i4qs.gif" alt="9gNGRJ.gif"><br><img src="http://wx2.sinaimg.cn/mw690/cfc08357gy1fp45f3pgl1g20dc07i7wj.gif" alt="9gN8G4.gif"></p><h2 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a>Todo</h2><ul><li>自动加载下一页图片</li><li>自动播放图片</li><li>看图支持评论与弹幕展示</li><li>双击图片直接点赞</li><li>右键直接到回答者页面看图</li></ul><h2 id="来贡献代码把"><a href="#来贡献代码把" class="headerlink" title="来贡献代码把"></a>来贡献代码把</h2><p>欢迎来提bug,来贡献代码.</p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      这个是受路人甲 之前发的一个插件的影响

我下载下来了 发现 竟然用不了。。。

而且只支持问题页看图

所以就修改了下。。。

而且开源放到了github上，主要是希望大家能一起维护他

毕竟靠一个人来做的话，是比较难的。。。

而且我比较懒。。。

我是个js菜鸟，代码有啥不忍直视的地方。。。

请随便喷。。。

如何安装
 1. 把项目下载到本地
    
    
 2. 在chrome浏览器的地址栏输入 chrome://extensions/
    
    
 3. 点击加载已解压的扩展程序
 4. 找到刚才下载的目录
 5. 如图所示，你就可以愉快的看图了
    

如何使
    
    </summary>
    
      <category term="知乎" scheme="https://jin10086.github.io/categories/%E7%9F%A5%E4%B9%8E/"/>
    
    
      <category term="chrome插件" scheme="https://jin10086.github.io/tags/chrome%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>从爬虫角度来说下360快视频事件</title>
    <link href="https://jin10086.github.io/2018/02/21/%E4%BB%8E%E7%88%AC%E8%99%AB%E8%A7%92%E5%BA%A6%E6%9D%A5%E8%AF%B4%E4%B8%8B360%E5%BF%AB%E8%A7%86%E9%A2%91%E4%BA%8B%E4%BB%B6/"/>
    <id>https://jin10086.github.io/2018/02/21/从爬虫角度来说下360快视频事件/</id>
    <published>2018-02-21T04:58:50.000Z</published>
    <updated>2018-04-04T07:12:10.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="360快视频事件"><a href="#360快视频事件" class="headerlink" title="360快视频事件"></a>360快视频事件</h2><blockquote><p>最开始好像是东方华灯宴的视频被发现被盗用，然后众用户排查发现大量B站视频被快视频盗用，连用户和评论也大量照搬，并有很多B站用户发现使用B站的用户名、密码可以直接在快视频上登录一个账号。</p></blockquote><p>详情可以看知乎问题页 <a href="https://www.zhihu.com/question/267364872" rel="external nofollow noopener noreferrer" target="_blank">如何看待360快视频大量盗用B站视频和用户个人信息数据？</a></p><h2 id="他是怎么实现的"><a href="#他是怎么实现的" class="headerlink" title="他是怎么实现的"></a>他是怎么实现的</h2><p>有网友是这样猜测的</p><blockquote><p>A.360主动参与了针对用户群体个人信息数据库的盗窃和/或非法买卖行为；<br>B.360一直在通过各种渠道(比如某些有名的“安全杀毒软件”)收集用户的录入信息，特别是用户名和密码；<br>C.用户名和密码都是B站用户托梦告诉360的；<br>D.今天天气真好。</p></blockquote><p>以上来自<a href="https://www.zhihu.com/question/267364872/answer/322975937" rel="external nofollow noopener noreferrer" target="_blank">如何看待360快视频大量盗用B站视频和用户<br>个人信息数据？ - 苏翻译的回答 - 知乎</a></p><p>我说句难听的话，这兄弟估计没有听说过爬虫…</p><p>那假如是我，要做出这种软件，我怎么做呢</p><h3 id="视频信息以及个人用户信息的抓取"><a href="#视频信息以及个人用户信息的抓取" class="headerlink" title="视频信息以及个人用户信息的抓取"></a>视频信息以及个人用户信息的抓取</h3><p>这个对360团队来说应该很简单，毕竟自己做了搜索引擎，很多公司都希望他来抓。</p><p>所以抓取视频信息，评论信息，做一个个人页，换上一样的id 以及头像都是很简单的。</p><p>因为这些信息 在B站上完全可以获取到</p><h3 id="为啥能用B站的账号能直接登陆360快视频？"><a href="#为啥能用B站的账号能直接登陆360快视频？" class="headerlink" title="为啥能用B站的账号能直接登陆360快视频？"></a>为啥能用B站的账号能直接登陆360快视频？</h3><p>很多人猜测是被脱裤了<br>也不是没有这个可能，不过这种方法不太好</p><ol><li>实时性不够高</li><li>有法律风险</li></ol><p>最简单的方法也是爬虫</p><p>具体如何实现的呢？<br>我画了一个小图</p><p>正常流程<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fonzrwcaimj20dc08174f.jpg" alt=""></p><p>360快视频的流程</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fonzuj8l8tj20iw0bzwf2.jpg" alt=""></p><p>简单的讲就是 当你在360快视频输入账号密码的时候，<strong>我把你的账号密码拿去B站模拟登陆，登陆成功则获取你在B站的个人页，然后让你跳转到360快视频对应的个人页</strong>，<br>如果登陆不成功，则把B站返回的内容（如用户名或者密码错误）返回给用户</p><h3 id="所以我没有拿到你的账号密码也可以做到和你的网站自动关联"><a href="#所以我没有拿到你的账号密码也可以做到和你的网站自动关联" class="headerlink" title="所以我没有拿到你的账号密码也可以做到和你的网站自动关联."></a>所以我没有拿到你的账号密码也可以做到和你的网站自动关联.</h3><h3 id="这个实现起来难么？"><a href="#这个实现起来难么？" class="headerlink" title="这个实现起来难么？"></a>这个实现起来难么？</h3><p>很简单把…</p><h3 id="你咋知道的？"><a href="#你咋知道的？" class="headerlink" title="你咋知道的？"></a>你咋知道的？</h3><p>我以前做过这种…</p><h3 id="还有别的例子么？"><a href="#还有别的例子么？" class="headerlink" title="还有别的例子么？"></a>还有别的例子么？</h3><ul><li>支付宝里面的公积金账号查询</li><li>一些第三方的学信网信息查询（还让你自己输入手机验证码呢！！！）</li><li>等等等…这个很普遍…</li></ul><h2 id="最后吐槽时间"><a href="#最后吐槽时间" class="headerlink" title="最后吐槽时间"></a>最后吐槽时间</h2><blockquote><p>你只要安装了360安全卫士，不出一个星期，你的电脑上就会莫名其妙出现一系列360的产品，这就是俗称的360全家桶。来源于<a href="http://zhuanlan.zhihu.com/p/33887437" rel="external nofollow noopener noreferrer" target="_blank">快视频：剽窃了B站的数据库？360的常规操作了。 - 温柔的文章 - 知乎</a></p></blockquote><p>我觉得360这件事做的不对，但是也不能随便诬赖人家啊。。。<br>我电脑包括公司里面的，<br>一直装了360<br>都用了接近快5年了，也没有被自动装上360全家桶啊。。。<br>难道是因为我装的是假的360 么？</p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      360快视频事件
最开始好像是东方华灯宴的视频被发现被盗用，然后众用户排查发现大量B站视频被快视频盗用，连用户和评论也大量照搬，并有很多B站用户发现使用B站的用户名、密码可以直接在快视频上登录一个账号。

详情可以看知乎问题页 如何看待360快视频大量盗用B站视频和用户个人信息数据？

他是怎么实现的
有网友是这样猜测的

A.360主动参与了针对用户群体个人信息数据库的盗窃和/或非法买卖行为；
B.360一直在通过各种渠道(比如某些有名的“安全杀毒软件”)收集用户的录入信息，特别是用户名和密码；
C.用户名和密码都是B站用户托梦告诉360的；
D.今天天气真好。

以上来自如何看待360快视
    
    </summary>
    
      <category term="爬虫" scheme="https://jin10086.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫的应用" scheme="https://jin10086.github.io/tags/%E7%88%AC%E8%99%AB%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>佛系编程[如何创建一个安全可靠的应用程序]</title>
    <link href="https://jin10086.github.io/2018/02/08/%E4%BD%9B%E6%80%A7%E7%BC%96%E7%A8%8B/"/>
    <id>https://jin10086.github.io/2018/02/08/佛性编程/</id>
    <published>2018-02-08T08:58:56.000Z</published>
    <updated>2018-04-04T07:12:10.671Z</updated>
    
    <content type="html"><![CDATA[<p>推荐最近在GitHub上很火的一个项目，按照介绍，你也可以创建一个安全可靠的应用程序</p><p><a href="https://github.com/kelseyhightower/nocode" rel="external nofollow noopener noreferrer" target="_blank">nocode</a><a href="https://github.com/kelseyhightower/nocode" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/kelseyhightower/nocode</a></p><p>以下是项目介绍</p><h1 id="No-Code"><a href="#No-Code" class="headerlink" title="No Code"></a>No Code</h1><p>No code is the best way to write secure and reliable applications. Write nothing; deploy nowhere.</p><h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><p>Start by not writing any code.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>This is just an example application, but imagine it doing anything you want. Adding new features is easy too:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>The possibilities are endless.</p><h3 id="Building-the-Application"><a href="#Building-the-Application" class="headerlink" title="Building the Application"></a>Building the Application</h3><p>Now that you have not done anything it’s time to build your application:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Yep. That’s it. You should see the following output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Deploying"><a href="#Deploying" class="headerlink" title="Deploying"></a>Deploying</h3><p>While you still have not done anything it’s time to deploy your application. By running the following command you can deploy your application absolutely nowhere.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>It’s that simple. And when it comes time to scale the application, all you have to do is:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>I know right?</p><h2 id="Contributing"><a href="#Contributing" class="headerlink" title="Contributing"></a>Contributing</h2><p>You don’t.</p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      推荐最近在GitHub上很火的一个项目，按照介绍，你也可以创建一个安全可靠的应用程序

nocodehttps://github.com/kelseyhightower/nocode

以下是项目介绍

No Code
No code is the best way to write secure and reliable applications. Write nothing; deploy nowhere.

Getting Started
Start by not writing any code.

1
2






This is just an example applicati
    
    </summary>
    
      <category term="编程随想" scheme="https://jin10086.github.io/categories/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="好玩的项目" scheme="https://jin10086.github.io/tags/%E5%A5%BD%E7%8E%A9%E7%9A%84%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>websocket与爬虫</title>
    <link href="https://jin10086.github.io/2018/02/04/websocket%E4%B8%8E%E7%88%AC%E8%99%AB/"/>
    <id>https://jin10086.github.io/2018/02/04/websocket与爬虫/</id>
    <published>2018-02-04T13:24:16.000Z</published>
    <updated>2018-04-04T07:12:10.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>写爬虫的目的应该就是为了拿到数据，或者说模拟某种操作<br>如果他使用的是http(s) 协议来传输数据的，那么我们就模拟http协议来发送数据<br>如果它使用的是websocket协议来传输数据的，<br>那么我们理所当然的就模拟websocket来发送数据~</p><p>首先，我们需要了解什么是websocket</p><h2 id="websocket的介绍"><a href="#websocket的介绍" class="headerlink" title="websocket的介绍"></a>websocket的介绍</h2><blockquote><p>WebSocket是一种在单个TCP连接上进行全双工通讯的协议。WebSocket通信协议于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准。</p></blockquote><blockquote><p>WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p></blockquote><p>上面是维基百科的介绍.<br>简单的将，websocket 和http一样，都是一种网络传输协议</p><h3 id="他比http协议好的地址有哪些呢？"><a href="#他比http协议好的地址有哪些呢？" class="headerlink" title="他比http协议好的地址有哪些呢？"></a>他比http协议好的地址有哪些呢？</h3><ul><li>较少的控制开销。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10字节（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的掩码。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。</li><li>更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。</li><li>保持连接状态。于HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。</li><li>更好的二进制支持。Websocket定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容。</li><li>可以支持扩展。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等。</li><li>更好的压缩效果。相对于HTTP压缩，Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率</li></ul><h3 id="websocket的应用场景"><a href="#websocket的应用场景" class="headerlink" title="websocket的应用场景"></a>websocket的应用场景</h3><ul><li>直播平台的弹幕</li><li>实时聊天</li><li>等等</li></ul><h2 id="websocket-协议"><a href="#websocket-协议" class="headerlink" title="websocket 协议"></a>websocket 协议</h2><p>WebSocket 是独立的、创建在 TCP 上的协议。</p><p>Websocket 通过 HTTP/1.1 协议的101状态码进行握手。</p><p>为了创建Websocket连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为“握手”</p><p>那么websocket协议是如何握手的呢？</p><h3 id="websocket握手"><a href="#websocket握手" class="headerlink" title="websocket握手"></a>websocket握手</h3><p>下面是websocket一次握手的过程<br><strong>客户端请求</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Host: example.com</span><br><span class="line">Origin: http://example.com</span><br><span class="line">Sec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure></p><p><strong>服务器响应</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=</span><br><span class="line">Sec-WebSocket-Location: ws://example.com/</span><br></pre></td></tr></table></figure></p><p><strong>和http字段不一样的地方</strong></p><ul><li>Connection必须设置Upgrade，表示客户端希望连接升级。</li><li>Upgrade字段必须设置Websocket，表示希望升级到Websocket协议。</li><li>Sec-WebSocket-Key是随机的字符串，服务器端会用这些数据来构造出一个SHA-1的信息摘要。把“Sec-WebSocket-Key”加上一个特殊字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，然后计算SHA-1摘要，之后进行BASE-64编码，将结果做为“Sec-WebSocket-Accept”头的值，返回给客户端。如此操作，可以尽量避免普通HTTP请求被误认为Websocket协议。</li><li>Sec-WebSocket-Version 表示支持的Websocket版本。RFC6455要求使用的版本是13，之前草案的版本均应当弃用。</li><li>Origin字段是可选的，通常用来表示在浏览器中发起此Websocket连接所在的页面，类似于Referer。但是，与Referer不同的是，Origin只包含了协议和主机名称。</li><li>其他一些定义在HTTP协议中的字段，如Cookie等，也可以在Websocket中使用。</li></ul><p>可以看到只是在http协议上增加了几个硬性规定，http协议的user-agent,cookie都可以在websocket握手过程中使用</p><p><strong>抓包时候的注意事项:因为websocket只有一次握手，握手成功后就可以双方发送消息了，假如你打开网页后没有找到你要抓的数据，那么你就需要重新刷新网页，让他重新握手一次</strong></p><h2 id="websocket的事件"><a href="#websocket的事件" class="headerlink" title="websocket的事件"></a>websocket的事件</h2><h3 id="on-open"><a href="#on-open" class="headerlink" title="on_open"></a>on_open</h3><p>表示刚刚连接的时候</p><h3 id="onmessage"><a href="#onmessage" class="headerlink" title="onmessage"></a>onmessage</h3><p>表示收到消息怎么做</p><h3 id="send"><a href="#send" class="headerlink" title="send"></a>send</h3><p>表示给服务器发送消息</p><h3 id="on-close"><a href="#on-close" class="headerlink" title="on_close"></a>on_close</h3><p>表示关闭连接</p><p>那么知道了这些对我们有什么好处么?<br>找js的时候会很好找，这几个关键词基本上都是固定的<br>你可以直接全局搜搜,然后很容易能找到发送的js代码</p><p>模拟发送的时候也是一样的.</p><h2 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h2><p>前面介绍了一堆websocket协议相关的东西，估计很多人已经晕了.<br>没关系，先看实例，有问题再回到上面看</p><h3 id="抓包可以使用fiddle，chrome也是可以的"><a href="#抓包可以使用fiddle，chrome也是可以的" class="headerlink" title="抓包可以使用fiddle，chrome也是可以的"></a>抓包可以使用fiddle，chrome也是可以的</h3><p>我们先使用chrome</p><p>本次要抓的网站的<a href="http://www.10brandchina.com/vote/startin.php?id=41867" rel="external nofollow noopener noreferrer" target="_blank">一个投票网站</a><br>大家可以先随便投一个票，抓抓包看看<br>会发现怎么没有找到他是如何提交数据的…</p><p>选择ws,然后刷新下网页，再点击下投票，会发现有一个请求<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo4rs5d7hjj20zf0bugmx.jpg" alt=""></p><p>可以看到是在握手阶段,请求头里面的参数和我们上面讲的是一样的.</p><p>请求地址是<code>ws://v5.10brandchina.com:8008/</code><br>这边顺带说一下，有时候这边会看到 <code>wss://v5.10brandchina.com:8008/</code><br>那么这两个有啥区别的，简单的讲就是http与https协议的区别一样…<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo4rykh56tj20ah027mx2.jpg" alt=""></p><p>看一下交互的内容（点击Frames）<br>可以看到已经有四条消息了，但是消息内容是二进制的，chrome这边无法预览…<br>那么我们使用fiddle试一下</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo4s0okwq0j20d505fmx7.jpg" alt=""></p><h3 id="抓包与分析"><a href="#抓包与分析" class="headerlink" title="抓包与分析"></a>抓包与分析</h3><p>打开fiddle，<strong>刷新一下网页</strong><br>不刷新的话是看不到的，然后随便投一下票.</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo4s4eceovj20ki08dmy3.jpg" alt=""></p><p>怎么找到请求呢，很简单，看状态码为101的就行，然后双击这一行</p><p>然后这边还是看到四条消息，我们点击第一条，然后用<code>TextView</code>展示，可以看到消息是这些<br>为啥用<code>TextView</code>呢？其实是一个一个的试过来的，假如你发现都试过了，还是乱码，那应该是他使用了其他的压缩或者加密方法，需要查看js看看他是如何加密的</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo4si2qs3uj20d1074t8w.jpg" alt=""></p><p>这个网站的数据是没有加密过的.<br>带向上的箭头的是我们向服务器发送的，向下的箭头是服务器返回的(下面的数据，前面带黑点？,是我们发送的)</p><ul><li><code>{&quot;action&quot;:&quot;auth&quot;,&quot;val&quot;:5}</code></li></ul><p><code>{&quot;action&quot;:&quot;auth&quot;,&quot;msg&quot;:&quot;eval(\&quot;\\115\\141\\164\\150\\56\\163\\151\\156\\50\\61\\65\\61\\67\\67\\66\\62\\63\\61\\63\\51\&quot;)&quot;}</code></p><ul><li><code>{&quot;action&quot;:&quot;auth&quot;,&quot;val&quot;:-0.3241458910493796}</code></li></ul><p><code>{&quot;action&quot;:&quot;wait&quot;,&quot;msg&quot;:95420}</code></p><ul><li><code>{&quot;action&quot;:&quot;vote&quot;,&quot;val&quot;:&quot;{\&quot;itemid\&quot;:126067,\&quot;catid\&quot;:41867,\&quot;captcha\&quot;:\&quot;%u7EC7%u65E7%u5F88%u9C7C\&quot;,\&quot;auth\&quot;:5,\&quot;rnd\&quot;:\&quot;4186712606754595\&quot;}&quot;}</code></li></ul><p><code>{&quot;action&quot;:&quot;vote&quot;,&quot;msg&quot;:&quot;ok,231812,2018-02-04 22:32:55&quot;}</code></p><p>可以看出来<br>首先我们发送<code>{&quot;action&quot;:&quot;auth&quot;,&quot;val&quot;:5}</code><br>然后服务器返回一串信息给我们,<br>然后我们根据服务器返回的算出一个值,也就是<br><code>{&quot;action&quot;:&quot;auth&quot;,&quot;val&quot;:-0.3241458910493796}</code><br>再发送给服务器.<br>服务器返回<code>{&quot;action&quot;:&quot;wait&quot;,&quot;msg&quot;:95420}</code>,表示验证通过<br>然后我们投票,发送了投票的一些信息给服务<br>服务器告诉我们投票成功.</p><p>以上就是整个通讯过程.</p><p>那如果我们要模拟发送的话，需要知道哪些信息呢</p><ol><li><code>{&quot;action&quot;:&quot;auth&quot;,&quot;val&quot;:5}</code>里面的<code>val:5</code>,这个5是固定的么？如果不是，是如何生成的</li><li>服务器返回的是什么，如何解析</li><li>如何根据服务器返回的生成一个新的val</li><li>发送投票信息里面<code>{&quot;action&quot;:&quot;vote&quot;,&quot;val&quot;:&quot;{\&quot;itemid\&quot;:126067,\&quot;catid\&quot;:41867,\&quot;captcha\&quot;:\&quot;%u7EC7%u65E7%u5F88%u9C7C\&quot;,\&quot;auth\&quot;:5,\&quot;rnd\&quot;:\&quot;4186712606754595\&quot;}&quot;}</code><br>itemid,catid,capthc,auth,rnd如何生成</li></ol><h2 id="找参数"><a href="#找参数" class="headerlink" title="找参数"></a>找参数</h2><p>还是使用chrome，直接用<code>ctrl + shift +f</code>，然后输入websocket（或者on_open,on_message，等等上面提到的事件去搜索）</p><p>运气很好，输入<code>websocket</code>直接就搜到了js,还是没有混淆的<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo4t04u89ej20i30410t0.jpg" alt=""></p><p>首先发现 websocket 地址是根据catId变的，如果catId能被2整除则地址为xxx，否则为xxx<br>那么catId是什么呢，调试发现就是url中的id，我们当前url为<code>http://www.10brandchina.com/vote/startin.php?id=41867</code>则 catId为<code>41867</code></p><p>然后onmessage也看到了，大概意思是收到信息后，用json解析，如果action是auth的话，则调用sendData这个方法，如果action是vote的话，则使用vote_resule方法.</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo4t2w87vsj20gp0fm0to.jpg" alt=""></p><p>在看到onopen方法，是调用sendData,并发送<code>(&#39;auth&#39;,authType)</code>,在这边是不是联想到前面，我们第一次发送的数据？<code>{&quot;action&quot;:&quot;auth&quot;,&quot;val&quot;:5}</code>,是不是感觉一模一样</p><p>close方法就不说了,反正我们也用不上<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo4tg5g7kyj20dl01ba9w.jpg" alt=""></p><p>再看看sendData这个方法,<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo4tj2ks1vj20hw07awet.jpg" alt=""><br>用python实现的话是这样<img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo4tnwvhgjj20cd02qt8n.jpg" alt=""></p><p>再看vote_result方法，大概作用是判断投票结果<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo4tpk059lj20nc0e0myk.jpg" alt=""></p><p>所有的方法我们都找到了，那么我们再和之前要找的参数走一遍.</p><ol><li><p><code>{&quot;action&quot;:&quot;auth&quot;,&quot;val&quot;:5}</code>里面的<code>val:5</code>,这个5是固定的么？如果不是，是如何生成的</p><p><strong>这个5也就是onopen里面的authType，至于authType是不是固定的，搜索一下就知道了.</strong></p></li><li><p>服务器返回的是什么，如何解析</p></li><li><p>如何根据服务器返回的生成一个新的val</p><p><strong>可以通过onmessage方法知道他返回的json数据，json解析一下就行，</strong><br><strong>里面的val是通过执行 <code>eval(val)</code>得到的</strong><br><strong>所以你也可以直接执行这个.或者用python实现</strong><br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo4twpructj20c109igm0.jpg" alt=""></p></li><li><p>发送投票信息里面<code>{&quot;action&quot;:&quot;vote&quot;,&quot;val&quot;:&quot;{\&quot;itemid\&quot;:126067,\&quot;catid\&quot;:41867,\&quot;captcha\&quot;:\&quot;%u7EC7%u65E7%u5F88%u9C7C\&quot;,\&quot;auth\&quot;:5,\&quot;rnd\&quot;:\&quot;4186712606754595\&quot;}&quot;}</code><br>itemid,catid,capthc,auth,rnd如何生成</p></li></ol><p><strong>itemid 就是你投票的公司的id，catid之前讲过，captcha就是验证码,</strong><br><strong>auth和上面的authtype一样</strong><br><strong>rnd是通过搜索js发现了.</strong><br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo4u0llrazj20uo03t0sz.jpg" alt=""></p><p>再看看验证码是如何生成的呢<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo4u2gg6f5j20o507x0t9.jpg" alt=""></p><p>检查验证码是否正确<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo4u3248gpj20um09adgu.jpg" alt=""></p><p>我们已经拿到所有需要的东西了，只要用程序模拟发送就行了.</p><h2 id="模拟发送"><a href="#模拟发送" class="headerlink" title="模拟发送"></a>模拟发送</h2><p>使用的包是<a href="https://github.com/websocket-client/websocket-client/" rel="external nofollow noopener noreferrer" target="_blank">websocket</a></p><p>官方demo<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> websocket</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> thread</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">import</span> _thread <span class="keyword">as</span> thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span><span class="params">(ws, message)</span>:</span></span><br><span class="line">    print(message)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_error</span><span class="params">(ws, error)</span>:</span></span><br><span class="line">    print(error)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_close</span><span class="params">(ws)</span>:</span></span><br><span class="line">    print(<span class="string">"### closed ###"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_open</span><span class="params">(ws)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(*args)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            ws.send(<span class="string">"Hello %d"</span> % i)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        ws.close()</span><br><span class="line">        print(<span class="string">"thread terminating..."</span>)</span><br><span class="line">    thread.start_new_thread(run, ())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    websocket.enableTrace(<span class="keyword">True</span>)</span><br><span class="line">    ws = websocket.WebSocketApp(<span class="string">"ws://echo.websocket.org/"</span>,</span><br><span class="line">                              on_message = on_message,</span><br><span class="line">                              on_error = on_error,</span><br><span class="line">                              on_close = on_close)</span><br><span class="line">    ws.on_open = on_open</span><br><span class="line">    ws.run_forever()</span><br></pre></td></tr></table></figure></p><p>可以看到使用还是很简单的，也是<code>onopen,onmessage,send</code></p><p>所以我们只要用我们上面得到的信息就行模拟发送就可以了</p><p>因为是投票网站，所以不提供代码…有啥问题，请留言~</p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      背景
写爬虫的目的应该就是为了拿到数据，或者说模拟某种操作
如果他使用的是http(s) 协议来传输数据的，那么我们就模拟http协议来发送数据
如果它使用的是websocket协议来传输数据的，
那么我们理所当然的就模拟websocket来发送数据~

首先，我们需要了解什么是websocket

websocket的介绍
WebSocket是一种在单个TCP连接上进行全双工通讯的协议。WebSocket通信协议于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准。

WebSocket使得客户端和服务器之间的数据交换变得更
    
    </summary>
    
      <category term="爬虫" scheme="https://jin10086.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="websocket" scheme="https://jin10086.github.io/tags/websocket/"/>
    
      <category term="websocket抓包" scheme="https://jin10086.github.io/tags/websocket%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>github如何创建ssh-key</title>
    <link href="https://jin10086.github.io/2018/02/03/github%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAssh-key/"/>
    <id>https://jin10086.github.io/2018/02/03/github如何创建ssh-key/</id>
    <published>2018-02-03T11:07:56.000Z</published>
    <updated>2018-04-04T07:12:10.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在写几个私有项目,每次提交都需要输入账号密码，很烦…</p><p>搜索发现如果使用ssh协议来提交的话，只要生成ssh key，就不需要输入账号密码了</p><h2 id="本地ssh-key的创建"><a href="#本地ssh-key的创建" class="headerlink" title="本地ssh-key的创建"></a>本地ssh-key的创建</h2><p>默认已经装好了git,如果没有安装的话，请百度如何安装</p><p>在命令行中输入下面命令<br><code>ssh-keygen -t rsa -C &quot;你的邮箱地址&quot;</code></p><p>如果提示找不到ssh-keygen 这个命令的话,请检查是否有安装git 以及是否要ssh-keygen加入环境变量<br>然后直接回车三连（三次回车）<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3h4q7e9xj20gz09wwf1.jpg" alt=""></p><p>然后 li* mac 等系统的同学 直接输入<br><code>cat ~/.ssh/id_rsa.pub</code> 然后直接复制里面的所有的内容</p><p>windows的同学,打开当前计算机名（如我当前计算机名是 <code>kimga</code><br><code>C:\Users\kimga\.ssh</code>下面的<code>id_rsa.pub</code>,然后复制里面的所有内容<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3h7ooj2gj20ay044jre.jpg" alt=""></p><h2 id="github-设置"><a href="#github-设置" class="headerlink" title="github 设置"></a>github 设置</h2><ol><li>打开github<a href="https://github.com/settings/ssh/new" rel="external nofollow noopener noreferrer" target="_blank">设置ssh-key的地址</a></li><li>在title里面输入你这个key用在哪的,(可以随便写)</li><li>在key里面粘贴进去上面复制的</li><li><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3haocqmmj20lt0c83yu.jpg" alt=""></li><li>点击add ssh key，然后输入GitHub密码就好了</li></ol><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在命令行输入<br><code>ssh -T git@github.com</code><br>会有一个警告,直接输入<code>yes</code><br>然后会看到 <code>Hi xxx! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code><br>则成功了<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3hfokg3kj20k103hmxf.jpg" alt=""></p><h2 id="在项目中使用ssh协议"><a href="#在项目中使用ssh协议" class="headerlink" title="在项目中使用ssh协议"></a>在项目中使用ssh协议</h2><p>有两种情况</p><ol><li><p>你项目还没有clone 下来，则你clone的时候直接使用ssh协议<br>如下图，点击Use SSH,然后复制地址<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3hj3l773j20b205y3yt.jpg" alt=""><br>正常clone，如<code>git clone git@github.com:jin10086/pachong.git</code></p></li><li><p>你项目已经clone下来了，但是用的是https协议，则需要更改下remote url<br>怎么做的，看下面</p><ol><li>输入<code>git remote -v</code> 查看当前的url，可以发现我使用的https协议</li><li><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3hm0gw5kj20cl020748.jpg" alt=""></li><li>输入<code>git remote set-url origin git@github.com:jin10086/pachong.git</code>,后面的git协议的地址获取方法和 方法1一样的.</li><li>输入<code>git remote -v</code>看看是否有修改成功</li><li><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3hnu7ygaj20k002owel.jpg" alt=""></li></ol></li></ol><p>最后，愉快的使用github把，再也不用每次都输入密码了~</p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      背景
最近在写几个私有项目,每次提交都需要输入账号密码，很烦…

搜索发现如果使用ssh协议来提交的话，只要生成ssh key，就不需要输入账号密码了

本地ssh-key的创建
默认已经装好了git,如果没有安装的话，请百度如何安装

在命令行中输入下面命令
ssh-keygen -t rsa -C &quot;你的邮箱地址&quot;

如果提示找不到ssh-keygen 这个命令的话,请检查是否有安装git 以及是否要ssh-keygen加入环境变量
然后直接回车三连（三次回车）


然后 li* mac 等系统的同学 直接输入
cat ~/.ssh/id_rsa.pub 然后直接复制里面的所有的内容

w
    
    </summary>
    
      <category term="github" scheme="https://jin10086.github.io/categories/github/"/>
    
    
      <category term="sshkey" scheme="https://jin10086.github.io/tags/sshkey/"/>
    
  </entry>
  
  <entry>
    <title>傻逼的我</title>
    <link href="https://jin10086.github.io/2018/02/03/%E5%82%BB%E9%80%BC%E7%9A%84%E6%88%91/"/>
    <id>https://jin10086.github.io/2018/02/03/傻逼的我/</id>
    <published>2018-02-03T10:41:16.000Z</published>
    <updated>2018-04-04T07:12:10.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前几天部门老大突然找到我，说因为我技术比较垃圾，所以不想和我续签了。（我还在试用期内）</p><p>然后我自己想了一晚上，觉得他说的一些地方我确实不足</p><p>然后就<strong>自己填了离职申请单</strong></p><p>过两天发现，和我一起进去的二位同事也被开了（也都在试用期内）。。。</p><p>而且我之前所在的部门也辞退了5个人（一共应该18个人左右把）</p><p>发现和我一起进去的同事竟然有补偿金</p><p>然后就问了hr说，为啥不给我补偿金，hr说因为我自己垃圾，所以不给。。。</p><p>然后我就申请了劳动仲裁。。。</p><p>结果呢，我输了</p><p>原因是啥呢，因为我填了<strong>离职申请单</strong>！！！</p><p>只要填了离职申请单，仲裁老师说 打官司肯定是输的，除非你有证据证明是他们逼你填的…</p><p>写出来呢，主要是为了给像我一样的小白提个醒，</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>不管公司说你垃圾，说你技术不行，如果要你走，千万不要主动填 离职申请单，填了的话，你申请仲裁肯定是输的，打官司也是输的</p></li><li><p>找个靠谱的公司</p></li><li><p>好好提升技术</p></li></ol><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      背景
前几天部门老大突然找到我，说因为我技术比较垃圾，所以不想和我续签了。（我还在试用期内）

然后我自己想了一晚上，觉得他说的一些地方我确实不足

然后就自己填了离职申请单

过两天发现，和我一起进去的二位同事也被开了（也都在试用期内）。。。

而且我之前所在的部门也辞退了5个人（一共应该18个人左右把）

发现和我一起进去的同事竟然有补偿金

然后就问了hr说，为啥不给我补偿金，hr说因为我自己垃圾，所以不给。。。

然后我就申请了劳动仲裁。。。

结果呢，我输了

原因是啥呢，因为我填了离职申请单！！！

只要填了离职申请单，仲裁老师说 打官司肯定是输的，除非你有证据证明是他们逼你填的…
    
    </summary>
    
      <category term="职场" scheme="https://jin10086.github.io/categories/%E8%81%8C%E5%9C%BA/"/>
    
    
      <category term="职场的坑" scheme="https://jin10086.github.io/tags/%E8%81%8C%E5%9C%BA%E7%9A%84%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>python版冲顶大会来了，该我们pythoner上场了</title>
    <link href="https://jin10086.github.io/2018/02/03/python%E7%89%88%E5%86%B2%E9%A1%B6%E5%A4%A7%E4%BC%9A%E6%9D%A5%E4%BA%86%EF%BC%8C%E8%AF%A5%E6%88%91%E4%BB%ACpythoner%E4%B8%8A%E5%9C%BA%E4%BA%86/"/>
    <id>https://jin10086.github.io/2018/02/03/python版冲顶大会来了，该我们pythoner上场了/</id>
    <published>2018-02-03T10:37:39.000Z</published>
    <updated>2018-04-04T07:12:10.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近，异常火爆的</p><p>「冲顶大会」or「百万英雄」or「知识超人」</p><p>每天都在我的朋友圈刷屏</p><p>不少人都陷入废寝忘食答题闯关的状态中</p><p>我也终于在越挫越勇不懈努力下</p><p>一次都没冲顶成功<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fzh1tvrj201s01sq2w.jpg" alt=""><br>不过，作为一个</p><p>追热点蹭关注精通各种互联网小道消息的</p><p>运营</p><p>聊人生哲学历史艺术算什么好汉！</p><p>不服你来我的主场</p><p>「python版冲顶大会」比一比</p><p>一共12道涵盖python热点及必备知识的问题 </p><p><img src="https://pic4.zhimg.com/v2-c14dbe46c110c10fe1313609bf209128_b.gif" alt=""></p><p>是<strong>pythoner</strong>就来冲顶！</p><p><a href="http://togetthere.cn/chongdingdahui.html" rel="external nofollow noopener noreferrer" target="_blank">冲顶大会地址在这</a><br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3g17mlxxj201s01sq2x.jpg" alt=""><br>最后P个S：主播是花大价钱请来的，异常貌美，不容错过！</p><p>创意抄的三节课的</p><p>代码也是抄的</p><p>就改了下题目</p><p>谢谢三节课爸爸</p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      背景
最近，异常火爆的

「冲顶大会」or「百万英雄」or「知识超人」

每天都在我的朋友圈刷屏

不少人都陷入废寝忘食答题闯关的状态中

我也终于在越挫越勇不懈努力下

一次都没冲顶成功

不过，作为一个

追热点蹭关注精通各种互联网小道消息的

运营

聊人生哲学历史艺术算什么好汉！

不服你来我的主场

「python版冲顶大会」比一比

一共12道涵盖python热点及必备知识的问题 



是pythoner就来冲顶！

冲顶大会地址在这

最后P个S：主播是花大价钱请来的，异常貌美，不容错过！

创意抄的三节课的

代码也是抄的

就改了下题目

谢谢三节课爸爸
    
    </summary>
    
      <category term="python" scheme="https://jin10086.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://jin10086.github.io/tags/python/"/>
    
      <category term="冲顶大会" scheme="https://jin10086.github.io/tags/%E5%86%B2%E9%A1%B6%E5%A4%A7%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title>再也不用担心网页编码的坑了！</title>
    <link href="https://jin10086.github.io/2018/02/03/%E5%86%8D%E4%B9%9F%E4%B8%8D%E7%94%A8%E6%8B%85%E5%BF%83%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A0%81%E7%9A%84%E5%9D%91%E4%BA%86%EF%BC%81/"/>
    <id>https://jin10086.github.io/2018/02/03/再也不用担心网页编码的坑了！/</id>
    <published>2018-02-03T10:32:31.000Z</published>
    <updated>2018-04-04T07:12:10.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>大家爬取网页的时候，应该都遇到过这种情况 </p><p>当我打印网页源代码的时候</p><p>发现 全部是乱码的</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fukg0paj20qz09j13g.jpg" alt=""><br>那这个时候应该怎么办呢？</p><h2 id="requests是如何判断编码"><a href="#requests是如何判断编码" class="headerlink" title="requests是如何判断编码"></a>requests是如何判断编码</h2><p>首先，response.content返回的内容 是二进制内容</p><p>response.text 则是根据设置的encoding来解码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Try charset from content-type  </span></span><br><span class="line">content = <span class="keyword">None</span>  </span><br><span class="line">encoding = self.encoding  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> self.content:  </span><br><span class="line">  <span class="keyword">return</span> str(<span class="string">''</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Fallback to auto-detected encoding.  </span></span><br><span class="line"><span class="keyword">if</span> self.encoding <span class="keyword">is</span> <span class="keyword">None</span>:  </span><br><span class="line">    encoding = self.apparent_encoding  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Decode unicode from given encoding.  </span></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    content = str(self.content, encoding, errors=<span class="string">'replace'</span>)  </span><br><span class="line"><span class="keyword">except</span> (LookupError, TypeError):</span><br></pre></td></tr></table></figure><p>我们可以看到 ，当encoding为None的时候，  </p><p>编码是通过chardet.detect来获取的,<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apparent_encoding</span><span class="params">(self)</span>:</span>  </span><br><span class="line"><span class="string">"""The apparent encoding, provided by the chardet library."""</span>  </span><br><span class="line">    <span class="keyword">return</span> chardet.detect(self.content)[<span class="string">'encoding'</span>]</span><br></pre></td></tr></table></figure></p><p>那么chardet.detect 又是干嘛的呢？</p><p>简单的讲，就是根据给定的字节，来返回他的编码</p><p>至于他是如何实现的，欢迎去看源代码。。。</p><p><strong>上面说到了当encoding为None的时候,requests是如何设置encoding的</strong></p><p><strong>那么encoding 默认编码是啥呢？继续查看源代码</strong></p><p>我们在adapters.py 里面找到了~<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">response.encoding = get_encoding_from_headers(response.headers)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_encoding_from_headers</span><span class="params">(headers)</span>:</span>  </span><br><span class="line"><span class="string">"""Returns encodings from given HTTP Header Dict.  </span></span><br><span class="line"><span class="string">    :param headers: dictionary to extract encoding from.  </span></span><br><span class="line"><span class="string">    :rtype: str  </span></span><br><span class="line"><span class="string">    """</span>  </span><br><span class="line">    content_type = headers.get(<span class="string">'content-type'</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> content_type:  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">None</span>  </span><br><span class="line">content_type, params = cgi.parse_header(content_type)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">'charset'</span> <span class="keyword">in</span> params:  </span><br><span class="line">  <span class="keyword">return</span> params[<span class="string">'charset'</span>].strip(<span class="string">"'\""</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> <span class="string">'text'</span> <span class="keyword">in</span> content_type:  </span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ISO-8859-1'</span></span><br></pre></td></tr></table></figure></p><p>简单讲就是 如何返回头里面没有content_type，则encoding为None</p><p>如果charset在参数里面的话，则使用charset设置的值（看下图，github返回的）</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fw3ge2tj20gt08yjuv.jpg" alt=""><br>如果text在参数里面的话，则使用<strong>ISO-8859-1</strong></p><p>然后你打印下 你乱码网页的encoding，发现，还真是<strong>ISO-8859-1</strong></p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fwbgdztj20k802kgmd.jpg" alt=""></p><p>你会很奇怪，为啥当content-type为text/html的时候，编码为iso-8859-1呢？</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fwjpdpzj20d605lwfx.jpg" alt=""><br>现在常见的编码不是utf8么，requests怎么这么傻*呢…</p><p>然后发现是rfc2016的规定。。。</p><p>rfc2016的链接在 <a href="https://www.ietf.org/rfc/rfc2616.txt" rel="external nofollow noopener noreferrer" target="_blank">https://www.ietf.org/rfc/rfc2616.txt</a></p><p>感兴趣的同学可以自行查阅…</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fws9qdoj20fm0don3j.jpg" alt=""></p><h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h2><p><strong>当返回头没有content_type 的时候，encoding使用chardet.detect 猜测出来的编码（一般都是很准的）</strong>  </p><p><strong>当返回头里面有content_type 的时候，如果有charset=xxx，则encoding的编码为chatset的值。如果只是text/html,则编码为ISO-8859-1</strong></p><p>那么当你发现response.text返回乱码的时候，怎么办呢。。。</p><p>只要先设置编码为None…</p><p>再打印.text就可以了..<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response.encoding = <span class="keyword">None</span>  </span><br><span class="line">response.text</span><br></pre></td></tr></table></figure></p><p>本来呢，本篇文章到此结束了。。。但是呢。。。</p><h2 id="科普个小知识"><a href="#科普个小知识" class="headerlink" title="科普个小知识"></a>科普个小知识</h2><p>有几种方法可以知道网页的编码呢？</p><ol><li>我们上面讲过的 response.headers中的content_type </li><li>通过chardet.detect猜测出来（上面讲过的） </li><li>网页源代码中的 meta（且有charset的值）如下面的，则表示网页编码为gb2312（不过呢，有时候并不是很准，这个是前端瞎xx写的，这时候就可以用chardet.detect来猜测了…） </li></ol><p>方法3的代码如何写呢（如下）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_encodings_from_content</span><span class="params">(content)</span>:</span>  </span><br><span class="line"><span class="string">"""Returns encodings from given content string.  </span></span><br><span class="line"><span class="string">    :param content: bytestring to extract encodings from.  </span></span><br><span class="line"><span class="string">    """</span>  </span><br><span class="line">    warnings.warn((  </span><br><span class="line"><span class="string">'In requests 3.0, get_encodings_from_content will be removed. For '</span>  </span><br><span class="line">        <span class="string">'more information, please see the discussion on issue #2266. (This'</span>  </span><br><span class="line">        <span class="string">' warning should only appear once.)'</span>),  </span><br><span class="line">        DeprecationWarning)  </span><br><span class="line">  </span><br><span class="line">    charset_re = re.compile(<span class="string">r'&amp;lt;meta.*?charset=["\']*(.+?)["\'&amp;gt;]'</span>, flags=re.I)  </span><br><span class="line">    pragma_re = re.compile(<span class="string">r'&amp;lt;meta.*?content=["\']*;?charset=(.+?)["\'&amp;gt;]'</span>, flags=re.I)  </span><br><span class="line">    xml_re = re.compile(<span class="string">r'^&amp;lt;\?xml.*?encoding=["\']*(.+?)["\'&amp;gt;]'</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> (charset_re.findall(content) +  </span><br><span class="line">            pragma_re.findall(content) +  </span><br><span class="line">            xml_re.findall(content))</span><br></pre></td></tr></table></figure></p><p>你会看到requests3.0版本的时候，这个方法会去掉，这又是为什么呢。。。</p><p>截图自己看把，地址在<a href="https://github.com/requests/requests/issues/2266" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/requests/requests/issues/2266</a></p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fxhmk9tj20o80gy7ck.jpg" alt=""></p><p>如果还有猜测编码的方法，欢迎留言</p><p>完…</p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      背景
大家爬取网页的时候，应该都遇到过这种情况 

当我打印网页源代码的时候

发现 全部是乱码的


那这个时候应该怎么办呢？

requests是如何判断编码
首先，response.content返回的内容 是二进制内容

response.text 则是根据设置的encoding来解码

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15


# Try charset from content-type  
content = None  
encoding = self.encoding  
  
if not self.content:  
  return 
    
    </summary>
    
      <category term="爬虫" scheme="https://jin10086.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="网页编码" scheme="https://jin10086.github.io/tags/%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>爬虫小工具-copyheader</title>
    <link href="https://jin10086.github.io/2018/02/03/%E7%88%AC%E8%99%AB%E5%B0%8F%E5%B7%A5%E5%85%B7-copyheader/"/>
    <id>https://jin10086.github.io/2018/02/03/爬虫小工具-copyheader/</id>
    <published>2018-02-03T10:25:31.000Z</published>
    <updated>2018-04-04T07:12:10.673Z</updated>
    
    <content type="html"><![CDATA[<p>大家写爬虫的，肯定知道如何伪造请求头了，那么你们是如何做的呢？</p><p>首先，来看看我之前是如何做的，有多烦我就不说了…</p><p><img src="https://pic1.zhimg.com/v2-f20b1ebea73a0481283d65f632e96a3d_r.gif" alt=""></p><p>如果有小伙伴是和我一样，那么请帮忙把这篇文章分享出去~</p><p><strong>那我现在怎么是怎么做的呢？</strong></p><p><img src="https://pic2.zhimg.com/v2-81aa0e4fee50c03a19d3d6bc587c1e55_r.gif" alt=""></p><p>可以发现复制请求头很简单了，只要把请求头全部copy下来，然后用headers_raw_to_dict 转一下，就直接变成了dict了.</p><h2 id="如何安装呢"><a href="#如何安装呢" class="headerlink" title="如何安装呢"></a>如何安装呢</h2><p><code>pip install copyheaders</code></p><h2 id="如何使用呢"><a href="#如何使用呢" class="headerlink" title="如何使用呢"></a>如何使用呢</h2><p>先找到你要复制的请求头，并且复制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 引入python包</span></span><br><span class="line"><span class="keyword">from</span> copyheaders <span class="keyword">import</span> headers_raw_to_dict</span><br><span class="line">impore requests</span><br><span class="line"><span class="comment"># 把刚刚复制的请求头复制进来</span></span><br><span class="line">r_h = <span class="string">b'''</span></span><br><span class="line"><span class="string">Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span></span><br><span class="line"><span class="string">Accept-Encoding:gzip, deflate, br</span></span><br><span class="line"><span class="string">Accept-Language:zh-CN,zh;q=0.9,zh-TW;q=0.8</span></span><br><span class="line"><span class="string">Cache-Control:max-age=0</span></span><br><span class="line"><span class="string">Connection:keep-alive</span></span><br><span class="line"><span class="string">Cookie:_gauges_unique_month=1; _gauges_unique_year=1; _gauges_unique=1; _gauges_unique_hour=1; _gauges_unique_day=1</span></span><br><span class="line"><span class="string">DNT:1</span></span><br><span class="line"><span class="string">Host:httpbin.org</span></span><br><span class="line"><span class="string">Referer:https://httpbin.org/</span></span><br><span class="line"><span class="string">Upgrade-Insecure-Requests:1</span></span><br><span class="line"><span class="string">User-Agent:Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 转换成字典</span></span><br><span class="line">headers = headers_raw_to_dict(r_h)</span><br><span class="line"><span class="comment"># 然后就可以直接使用了~</span></span><br><span class="line">z = requests.get(<span class="string">'https://httpbin.org/headers'</span>,headers=headers</span><br></pre></td></tr></table></figure><p>项目地址在<a href="https://github.com/jin10086/copyheaders" rel="external nofollow noopener noreferrer" target="_blank">copyheaders</a></p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      大家写爬虫的，肯定知道如何伪造请求头了，那么你们是如何做的呢？

首先，来看看我之前是如何做的，有多烦我就不说了…



如果有小伙伴是和我一样，那么请帮忙把这篇文章分享出去~

那我现在怎么是怎么做的呢？



可以发现复制请求头很简单了，只要把请求头全部copy下来，然后用headers_raw_to_dict 转一下，就直接变成了dict了.

如何安装呢
pip install copyheaders

如何使用呢
先找到你要复制的请求头，并且复制

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21


# 引入python包

    
    </summary>
    
      <category term="爬虫" scheme="https://jin10086.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫工具" scheme="https://jin10086.github.io/tags/%E7%88%AC%E8%99%AB%E5%B7%A5%E5%85%B7/"/>
    
      <category term="copyheaders" scheme="https://jin10086.github.io/tags/copyheaders/"/>
    
  </entry>
  
  <entry>
    <title>模拟登陆知乎</title>
    <link href="https://jin10086.github.io/2018/02/03/%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86%E7%9F%A5%E4%B9%8E/"/>
    <id>https://jin10086.github.io/2018/02/03/模拟登陆知乎/</id>
    <published>2018-02-03T10:19:32.000Z</published>
    <updated>2018-04-04T07:12:10.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>为啥要写这一篇文章呢？<br>（主要是qq群内有人在模拟登陆知乎，一直不成功）然后我抓包看了下，发现知乎登陆页已经改版了，而且难度大大提高了。</p><h2 id="开始抓包"><a href="#开始抓包" class="headerlink" title="开始抓包"></a>开始抓包</h2><p>首先内，还是打开知乎首页，然后输入账号密码，登陆（记得输错密码）  </p><p>这样我们就可以看到请求头了（请求头如下）<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fgpbpfwj20s10aadp4.jpg" alt=""><br>我们发现有这几个请求头和正常的不一样（红色框中的）</p><ol><li><code>authorization</code> （感觉应该是js生成的，后面再看</li><li><code>Content-Type</code> （后面多了boundary=xxx 这种,那这种是啥意思呢,后面和请求参数一起看</li><li><code>cookie</code>：这个要注意,登陆前cookie就不为空，说明之前肯定有set-cookie的操作</li><li><code>x-udid,x-sxrftoken</code> 这两个都是验证参数,估计都在网页源代码能找到</li></ol><p>再看一下请求参数</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fgywrwfj20a50d1goo.jpg" alt=""><br>可以看到参数是以payload的形式出现的</p><p>第一次看到这种的人估计会一脸懵逼</p><p>这个要结合请求中的<code>Content-Type</code>:<code>multipart/form-data; boundary=----WebKitFormBoundary2KNsyxgtG28t93VF</code><br>来一起看</p><p><code>multipart/form-data</code> 是一种表单提交的方式，后面的boundary=xxx 是表单分割的方式，那到底啥意思呢？看一个简单的小列子你就能明白啦</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fhy0z52j20df04c40r.jpg" alt=""><br><code>------WebKitFormBoundary2KNsyxgtG28t93VF</code> 是分割不同参数的，所以可以直接不看他（这个是由上面的Content-Type后面的boundary决定的，可以随便修改）</p><p>那把分割线去掉后，上面的就相当于 <code>client_id=c3cef7c66a1843f8b3a9e6a1e3160e20</code>,</p><p><code>grant_type=password</code>.</p><p>那么这个payload就很好理解了.</p><p>我们来看一下，一共有哪些参数</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fi7frqjj20t60fjn3c.jpg" alt=""><br>参数还挺多的，可以看到很多参数都是固定的，如账号，密码，时间戳，等等</p><p>变动的有两个 client_id,signature</p><h2 id="开始找参数"><a href="#开始找参数" class="headerlink" title="开始找参数"></a>开始找参数</h2><p><code>authorization</code>：</p><p>我们在chrome内，直接按ctrl+shift+f(全局搜索，搜索js,css这些)，可以看到已经搜索到了，并且是直接写在js里面的，然后重新随便换个账号再抓一次包，发现authorization 的值还是固定的，所以说明authorization 是直接写在js里面的，不是动态修改的(那么authorization 的值我们就已经找到了）</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3filrwi9j20kr053tbj.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3firqfpjj20gc09lq71.jpg" alt=""><br><code>cookie</code>：</p><p>在登陆之前，就发现cookie的值不为空，说明肯定打开网页后就有set-cookie的操作了，我们想验证的话，先打开一个无痕浏览器（主要是为了把之前的cookie全部清空，避免干扰），然后打开<a href="http://zhihu.com/" rel="external nofollow noopener noreferrer" target="_blank">http://zhihu.com</a>，我们发现他有几次set-cookie的动作</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fj4op6sj20rm06f78i.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fjayv50j20qe06tgqo.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fjjbul8j20ty06yjxl.jpg" alt=""><br>那我们想要模拟的话，很简单的方法是直接使用requests.session</p><p><code>x-udid,x-sxrftoken</code>:</p><p>一般这种验证参数都会在网页源代码里面,所以直接查看网页源代码</p><p>可以看到已经找到了,后续就是如何把这个找出来而已，可以使用正则，或者xpath定位到</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fjyl8ltj20tq09rnfl.jpg" alt=""><br><code>client_id</code>:</p><p>你会发现client_id与上面的authorization 一模一样</p><p><code>signature</code>:</p><p>还是使用ctrl+shift+f 全局搜索</p><p>发现找到了，但是参数是js动态生成的…</p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fkaq7tzj20x909wah2.jpg" alt=""><br>主要是找到如何加密的，然后使用Python模拟出来</p><p>第一步：下载这个js，格式化（让代码好看一些）</p><p>第二步：使用fiddle替换掉原来的js，使用刚刚格式化的js</p><p>第三步：慢慢调试。。。直到找到如何生成的…</p><p>大概步骤是这样</p><p>但是假如你js像我一样很渣的话，你可以直接找到这段加密的js，然后Python执行这段js就可以了。。。</p><h2 id="上面呢，我们把该找的参数都找到了，接着只要模拟发送就可以了"><a href="#上面呢，我们把该找的参数都找到了，接着只要模拟发送就可以了" class="headerlink" title="上面呢，我们把该找的参数都找到了，接着只要模拟发送就可以了"></a>上面呢，我们把该找的参数都找到了，接着只要模拟发送就可以了</h2><p><a href="https://github.com/jin10086/pachong/blob/master/zhihulogin.py" rel="external nofollow noopener noreferrer" target="_blank">知乎登陆代码在这</a></p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      原因
为啥要写这一篇文章呢？
（主要是qq群内有人在模拟登陆知乎，一直不成功）然后我抓包看了下，发现知乎登陆页已经改版了，而且难度大大提高了。

开始抓包
首先内，还是打开知乎首页，然后输入账号密码，登陆（记得输错密码） 

这样我们就可以看到请求头了（请求头如下）

我们发现有这几个请求头和正常的不一样（红色框中的）

 1. authorization （感觉应该是js生成的，后面再看
 2. Content-Type （后面多了boundary=xxx 这种,那这种是啥意思呢,后面和请求参数一起看
 3. cookie：这个要注意,登陆前cookie就不为空，说明之前肯定有set-coo
    
    </summary>
    
      <category term="爬虫" scheme="https://jin10086.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫实战" scheme="https://jin10086.github.io/tags/%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98/"/>
    
      <category term="模拟登陆知乎" scheme="https://jin10086.github.io/tags/%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86%E7%9F%A5%E4%B9%8E/"/>
    
  </entry>
  
  <entry>
    <title>请正确使用http状态码，谢谢！</title>
    <link href="https://jin10086.github.io/2018/02/03/%E8%AF%B7%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8http%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%8C%E8%B0%A2%E8%B0%A2%EF%BC%81/"/>
    <id>https://jin10086.github.io/2018/02/03/请正确使用http状态码，谢谢！/</id>
    <published>2018-02-03T10:13:25.000Z</published>
    <updated>2018-04-04T07:12:10.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近，由于某些特别原因。打开一些网址一直显示404，<br>想请问下，xx站的程序员，能不能按照http协议来返回呢？</p><h2 id="什么是http状态码451"><a href="#什么是http状态码451" class="headerlink" title="什么是http状态码451"></a>什么是http状态码451</h2><blockquote><p>根据定义，HTTP 451错误代码状态出现，不代表这个地址是否存在，而代表该网页可能对于国家安全产生危险，或是该网页可能违反著作权、隐私权、亵渎神明或其他法律或法院命令。<br>该响应代码有如下的性质：<br>除非另外指明，否则这个响应代码是可以被缓存的。<br>必须携带一个带有一个Link头部，列出要求封禁该地址的实体URI；且应带有一个”rel”字段，值应为”blocked-by”[1]。<br>简单的讲 就是由于某些政治原因，所以，该页面不予访问</p></blockquote><h2 id="HTTP451的来源"><a href="#HTTP451的来源" class="headerlink" title="HTTP451的来源"></a>HTTP451的来源</h2><blockquote><p>本代码于2013年由提姆·布雷（Tim Bray）正式提出，主要基于博客Terence Eden的文章所提出的非正式提案[2]。2015年12月18日，此代码由国际网络工程研究团队通过[3]。<br>451这个代码源于1953年的反乌托邦小说《华氏451度》(纸的燃点为华氏451度)，在这部小说中，所有书籍是违禁品[4]。相比较HTTP 403代码，451可更好描述一种由于法律规定或受权威部门要求而导致的封禁状态[5]</p></blockquote><h2 id="一个示例"><a href="#一个示例" class="headerlink" title="一个示例"></a>一个示例</h2><p>某地一用户以GET方式请求<a href="http://example.org的/index.php路径：" rel="external nofollow noopener noreferrer" target="_blank">http://example.org的/index.php路径：</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /index.php HTTP/1.1</span><br><span class="line">Host: www.example.org</span><br></pre></td></tr></table></figure><p>由于用户所在地的某项法律规定，网站不可以向该地区用户返回这个页面，所以服务器做出回应，设置了有效期为一年的缓存头部，并在Link头部中加入了指定的政府部门URL<code>http://www.xxx.gov.tld</code><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 451 Unavailable For Legal Reasons</span><br><span class="line">Link: <span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.xxx.gov.tld</span>&gt;</span>; rel="blocked-by"</span><br><span class="line">Cache-control: max-age=31536000; public</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>因法律原因不可用<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>HTTP/1.1 451 因法律原因，本页面不可用<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>根据《某法》第某条之规定，本网站页面对来自某地的访客不可用。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3fco2j5kj219m0b3dtv.jpg" alt=""></p><p>文章参考于 维基百科 <a href="https://zh.wikipedia.org/wiki/HTTP_451" rel="external nofollow noopener noreferrer" target="_blank">https://zh.wikipedia.org/wiki/HTTP_451</a></p><p><a href="https://tools.ietf.org/html/rfc7725" rel="external nofollow noopener noreferrer" target="_blank">RFC 7725</a> - HTTP 451的正式RFC文件</p><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      背景
最近，由于某些特别原因。打开一些网址一直显示404，
想请问下，xx站的程序员，能不能按照http协议来返回呢？

什么是http状态码451
根据定义，HTTP 451错误代码状态出现，不代表这个地址是否存在，而代表该网页可能对于国家安全产生危险，或是该网页可能违反著作权、隐私权、亵渎神明或其他法律或法院命令。
该响应代码有如下的性质：
除非另外指明，否则这个响应代码是可以被缓存的。
必须携带一个带有一个Link头部，列出要求封禁该地址的实体URI；且应带有一个”rel”字段，值应为”blocked-by”[1]。
简单的讲 就是由于某些政治原因，所以，该页面不予访问

HTTP451
    
    </summary>
    
      <category term="爬虫" scheme="https://jin10086.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="http状态吗" scheme="https://jin10086.github.io/tags/http%E7%8A%B6%E6%80%81%E5%90%97/"/>
    
      <category term="http451" scheme="https://jin10086.github.io/tags/http451/"/>
    
  </entry>
  
  <entry>
    <title>知乎想法抽奖专用</title>
    <link href="https://jin10086.github.io/2018/02/03/%E7%9F%A5%E4%B9%8E%E6%83%B3%E6%B3%95%E6%8A%BD%E5%A5%96%E4%B8%93%E7%94%A8/"/>
    <id>https://jin10086.github.io/2018/02/03/知乎想法抽奖专用/</id>
    <published>2018-02-03T10:09:21.000Z</published>
    <updated>2018-04-04T07:12:10.673Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>很久没有更新专栏了，写一个好玩的把（刚好最近很多人有需求）<br>废话不多说，直接看代码把（接口是通过抓取手机app的包获取的，不会的话请看<a href="https://zhuanlan.zhihu.com/p/26785815" rel="external nofollow noopener noreferrer" target="_blank">抓取手机app的数据（摩拜单车）</a>）</p><h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><ol><li>打开想法详情页<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3f7feuo5j20yi1pcno3.jpg" alt=""></li><li>点击复制链接<br><img src="http://ww1.sinaimg.cn/large/cfc08357gy1fo3f7yjk4dj20k00zk7hc.jpg" alt=""></li><li><code>python zhihu.py --url 刚刚复制的网址</code></li></ol><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟浏览器头</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'host'</span>: <span class="string">"api.zhihu.com"</span>,</span><br><span class="line">    <span class="string">'accept'</span>: <span class="string">"*/*"</span>,</span><br><span class="line">    <span class="string">'x-app-za'</span>: <span class="string">"OS=iOS&amp;Release=10.3.3&amp;Model=iPhone8,2&amp;VersionName=4.1.0&amp;VersionCode=683&amp;Width=1242&amp;Height=2208&amp;DeviceType=Phone&amp;Brand=Apple&amp;OperatorType=46001"</span>,</span><br><span class="line">    <span class="string">'x-udid'</span>: <span class="string">"AHCAH2SzkApLBWvOUMZ7s9hG-Zh-_NhtVCM="</span>,</span><br><span class="line">    <span class="string">'x-app-versioncode'</span>: <span class="string">"683"</span>,</span><br><span class="line">    <span class="string">'accept-language'</span>: <span class="string">"zh-Hans-CN;q=1, en-CN;q=0.9"</span>,</span><br><span class="line">    <span class="string">'accept-encoding'</span>: <span class="string">"gzip, deflate"</span>,</span><br><span class="line">    <span class="string">'x-api-version'</span>: <span class="string">"3.0.64"</span>,</span><br><span class="line">    <span class="string">'authorization'</span>: <span class="string">"Bearer gt2.0AAAAAAX1feoKkLNkH4BwAAAAAAtNVQJgAgBgPzk1-59vTbuXI60W0XlSl-wNBg=="</span>,</span><br><span class="line">    <span class="string">'x-network-type'</span>: <span class="string">"WiFi"</span>,</span><br><span class="line">    <span class="string">'user-agent'</span>: <span class="string">"osee2unifiedRelease/4.1.0 (iPhone; iOS 10.3.3; Scale/3.00)"</span>,</span><br><span class="line">    <span class="string">'x-app-build'</span>: <span class="string">"release"</span>,</span><br><span class="line">    <span class="string">'x-app-version'</span>: <span class="string">"4.1.0"</span>,</span><br><span class="line">    <span class="string">'x-suger'</span>: <span class="string">"SURGVj0wNDA5NjgxMS01NTI5LTRDQUQtQUEzNi1FRkI2M0VDQThDOEE7SURGQT01MDM2NDdEMy01QTlDLTRFMjItODA5NS1FRkUyM0Y5Mzg5QzM="</span>,</span><br><span class="line">    <span class="string">'cookie'</span>: <span class="string">"aliyungf_tc=AQAAAH4w9XP89AUAWgqDdYQRcynwI6xp; q_c1=97515fa2381f48a7b6ef8d46de8bc7be|1505561812000|1505561812000; z_c0=gt2.0AAAAAAX1feoKkLNkH4BwAAAAAAtNVQJgAgBgPzk1-59vTbuXI60W0XlSl-wNBg==; _xsrf=a31505e0-0f69-440b-b357-30fffc9838bd; cap_id=\"MzQ2NGE0NThiMmVjNDU3MmE5MzVhYzE0OGYyMTYzYTI=|1505561809|0c36cb283969855952e9e895b77211fd292c0df7\"; l_cap_id=\"ODE3YzMwODM5ZTE0NDdjN2IxY2UyZDdiYjQ1MGYzNDg=|1505561809|6f707b1bf6c0a0ebb6391d0c421ac06e49ceca3b\"; r_cap_id=\"ODZlYTZmNGZhYzU3NDgwOGE4YzUyOWI5OTBmMzA3NjQ=|1505561809|05c714d01ee35a0a6c96b0c330d4f10434fec8bc\""</span>,</span><br><span class="line">    <span class="string">'cache-control'</span>: <span class="string">"no-cache"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'get url ---&#123;&#125;'</span>.format(url))</span><br><span class="line">    z = requests.get(url, headers=headers, verify=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> z.json()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(url)</span>:</span></span><br><span class="line">    jsdata = get(url)</span><br><span class="line">    info = []</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> jsdata[<span class="string">'data'</span>]:</span><br><span class="line">            <span class="keyword">if</span> i[<span class="string">'action_type'</span>] == <span class="string">'repin'</span>:</span><br><span class="line">                info.append(&#123;</span><br><span class="line">                    <span class="string">'url'</span>: i[<span class="string">'member'</span>][<span class="string">'url'</span>],</span><br><span class="line">                    <span class="string">'name'</span>: i[<span class="string">'member'</span>][<span class="string">'name'</span>],</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment"># print(i['member']['url'], print(i['member']['name']))</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> jsdata[<span class="string">'paging'</span>][<span class="string">'is_end'</span>]:</span><br><span class="line">            jsdata = get(jsdata[<span class="string">'paging'</span>][<span class="string">'next'</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> info</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">'知乎想法抽奖'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--url'</span>, type=str, default=<span class="keyword">None</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    baseurl = <span class="string">'https://api.zhihu.com/pins/&#123;&#125;/actions?limit=20&amp;offset=0'</span></span><br><span class="line">    url = args.url</span><br><span class="line">    pin = url.split(<span class="string">'/'</span>)[<span class="number">-1</span>]</span><br><span class="line">    <span class="comment"># 修复 当网址分享到qq的时候 有后缀的问题，如https://www.zhihu.com/pin/900498393586094080?utm_source=qq</span></span><br><span class="line">    pin_id = re.search(<span class="string">'\d+'</span>,pin)[<span class="number">0</span>]</span><br><span class="line">    url = baseurl.format(pin_id)</span><br><span class="line">    info = run(url)</span><br><span class="line">    print(len(info))</span><br><span class="line">    print(<span class="string">'********本次抽奖获得者为********'</span>)</span><br><span class="line">    print(choice(info))</span><br><span class="line">    print(<span class="string">'********本次抽奖获得者为********'</span>)</span><br></pre></td></tr></table></figure><script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>]]></content>
    
    <summary type="html">
    
      背景
很久没有更新专栏了，写一个好玩的把（刚好最近很多人有需求）
废话不多说，直接看代码把（接口是通过抓取手机app的包获取的，不会的话请看抓取手机app的数据（摩拜单车））

怎么用
 1. 打开想法详情页
    
 2. 点击复制链接
    
 3. python zhihu.py --url 刚刚复制的网址

代码如下
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
    
    </summary>
    
      <category term="爬虫" scheme="https://jin10086.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫实战" scheme="https://jin10086.github.io/tags/%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98/"/>
    
      <category term="知乎想法抽奖" scheme="https://jin10086.github.io/tags/%E7%9F%A5%E4%B9%8E%E6%83%B3%E6%B3%95%E6%8A%BD%E5%A5%96/"/>
    
  </entry>
  
</feed>
